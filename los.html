<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio LOS & Path Loss Tool</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LeafletJS for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Leaflet MarkerCluster for avoiding marker overlap -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

    <!-- Chart.js for profile visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* Set a default font and ensure the map container has a defined height */
        body {
            font-family: 'Inter', sans-serif;
        }
        #map {
            height: 500px; /* Increased height for better view */
            border-radius: 0.5rem;
            z-index: 10;
        }
        /* Custom styles for Leaflet popups */
        .leaflet-popup-content-wrapper {
            border-radius: 0.5rem;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .crosshair-cursor {
            cursor: crosshair !important;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Radio LOS & Path Loss Tool</h1>
            <p class="text-lg text-gray-600 mt-2">Analyze repeater line-of-sight and estimate RF path loss.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: Controls and Repeater List -->
            <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Controls</h2>
                
                <div class="space-y-4">
                    <div>
                        <label for="gpx-upload" class="block text-sm font-medium text-gray-700">Upload Repeaterbook GPX</label>
                        <input type="file" id="gpx-upload" accept=".gpx" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="latitude" class="block text-sm font-medium text-gray-700">Your Latitude</label>
                            <input type="number" id="latitude" placeholder="e.g., 43.653" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="longitude" class="block text-sm font-medium text-gray-700">Your Longitude</label>
                            <input type="number" id="longitude" placeholder="e.g., -79.383" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                    </div>
                     <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="user-height" class="block text-sm font-medium text-gray-700">Your Height (m)</label>
                            <input type="number" id="user-height" value="10" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="repeater-height" class="block text-sm font-medium text-gray-700">Default Ht. (m)</label>
                            <input type="number" id="repeater-height" value="30" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                    </div>
                    <div class="flex items-center">
                        <input id="curvature-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" checked>
                        <label for="curvature-checkbox" class="ml-2 text-sm font-medium text-gray-700">Earth Curvature</label>
                    </div>
                    <div class="flex space-x-2">
                         <button id="resetLocationBtn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300">Reset to My Location</button>
                         <button id="addMarkerBtn" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300">Place Custom Marker</button>
                    </div>
                    <div id="custom-marker-input-container" class="hidden space-y-2 mt-2 border-t pt-4">
                        <label for="custom-marker-name" class="block text-sm font-medium text-gray-700">Custom Marker Name (optional)</label>
                        <input type="text" id="custom-marker-name" placeholder="Enter name..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                        <label for="custom-marker-freq" class="block text-sm font-medium text-gray-700">Frequency (MHz)</label>
                        <input type="number" id="custom-marker-freq" value="146.520" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                </div>
                
                <h2 class="text-2xl font-semibold mt-8 mb-4 border-b pb-2">Nearby Repeaters</h2>
                <div class="mb-4">
                    <input type="text" id="repeater-search" placeholder="Search callsign, freq, location..." class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <!-- Analysis Filter UI -->
                <div class="mb-4 p-4 bg-indigo-50 rounded-lg space-y-3">
                    <div id="filter-controls-grid" class="grid grid-cols-2 gap-4 items-end">
                        <div>
                            <label for="filter-mode-select" class="block text-sm font-medium text-gray-700">Filter Mode</label>
                            <select id="filter-mode-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option value="none">None</option>
                                <option value="pathLoss" selected>Path Loss</option>
                                <option value="los">Line of Sight</option>
                            </select>
                        </div>
                        <div id="path-loss-container">
                            <label for="max-path-loss-input" class="block text-sm font-medium text-gray-700">Max Loss (dB)</label>
                            <input type="number" id="max-path-loss-input" value="150" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                    </div>
                    <button id="run-batch-analysis" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 whitespace-nowrap">Analyze All Repeaters</button>
                </div>

                <div id="filter-status" class="text-sm text-gray-600 mb-2"></div>
                <div id="repeater-list" class="space-y-2 max-h-60 overflow-y-auto">
                    <p class="p-3 text-gray-500">Upload a GPX file or load a set to see repeater data.</p>
                </div>

                <h2 class="text-2xl font-semibold mt-4 mb-4 border-b pb-2">Custom Locations</h2>
                <div id="custom-list" class="space-y-2 max-h-40 overflow-y-auto">
                     <p class="p-3 text-gray-500">Click "Place Custom Marker" to add locations.</p>
                </div>

                <!-- Manage Sets for Desktop -->
                <div class="hidden lg:block mt-8 border-t pt-4">
                    <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Manage Sets</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="set-select-desktop" class="block text-sm font-medium text-gray-700">Load Set</label>
                            <select id="set-select-desktop" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                        </div>
                        <div>
                            <label for="set-name-input-desktop" class="block text-sm font-medium text-gray-700">New Set Name</label>
                            <input type="text" id="set-name-input-desktop" placeholder="Enter name to save..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                            <p id="set-error-msg-desktop" class="text-red-500 text-xs hidden mt-1">Please enter a name for the set.</p>
                        </div>
                        <div class="flex space-x-2">
                            <button id="saveSetBtn-desktop" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300">Save Current Set</button>
                            <button id="deleteSetBtn-desktop" class="w-full bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-700 transition duration-300">Delete Selected Set</button>
                        </div>
                         <div id="delete-confirmation-desktop" class="hidden space-y-2 mt-2 border-t pt-4">
                            <p class="text-sm text-center font-semibold">Are you sure? This is permanent.</p>
                             <div class="flex space-x-2">
                                 <button id="confirmDeleteBtn-desktop" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">Yes, Delete</button>
                                 <button id="cancelDeleteBtn-desktop" class="w-full bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400">Cancel</button>
                             </div>
                        </div>
                         <div>
                            <button id="clearDataBtn-desktop" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 mt-4">Clear All Saved Data</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Map and Results -->
            <div class="lg:col-span-2 bg-white p-6 rounded-lg shadow-lg">
                <div id="map" class="mb-6 border border-gray-200"></div>
                
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Selected Target Details</h2>
                <div id="selected-repeater-info" class="p-4 rounded-lg bg-gray-50">
                    <p class="text-gray-500">Select a target to see its details here.</p>
                </div>

                <h2 class="text-2xl font-semibold mt-6 mb-4 border-b pb-2">Line-of-Sight Analysis</h2>
                <div id="los-result-container" class="text-center p-4 rounded-lg bg-gray-50">
                     <p class="text-gray-500">Select a target from the list to analyze the path.</p>
                </div>
                
                <h2 class="text-2xl font-semibold mt-6 mb-4 border-b pb-2">RF Path Loss</h2>
                <div id="path-loss-result-container" class="text-center p-4 rounded-lg bg-gray-50">
                    <p class="text-gray-500">Path loss is calculated for clear line-of-sight paths.</p>
                </div>
                
                <div class="mt-6">
                    <canvas id="profileChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Manage Sets for Mobile -->
        <div class="lg:hidden mt-8 bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Manage Sets</h2>
            <div class="space-y-4">
                <div>
                    <label for="set-select-mobile" class="block text-sm font-medium text-gray-700">Load Set</label>
                    <select id="set-select-mobile" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                </div>
                <div>
                    <label for="set-name-input-mobile" class="block text-sm font-medium text-gray-700">New Set Name</label>
                    <input type="text" id="set-name-input-mobile" placeholder="Enter name to save..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    <p id="set-error-msg-mobile" class="text-red-500 text-xs hidden mt-1">Please enter a name for the set.</p>
                </div>
                <div class="flex space-x-2">
                    <button id="saveSetBtn-mobile" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300">Save Current Set</button>
                    <button id="deleteSetBtn-mobile" class="w-full bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-700 transition duration-300">Delete Selected Set</button>
                </div>
                 <div id="delete-confirmation-mobile" class="hidden space-y-2 mt-2 border-t pt-4">
                    <p class="text-sm text-center font-semibold">Are you sure? This is permanent.</p>
                     <div class="flex space-x-2">
                         <button id="confirmDeleteBtn-mobile" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">Yes, Delete</button>
                         <button id="cancelDeleteBtn-mobile" class="w-full bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400">Cancel</button>
                     </div>
                </div>
                 <div>
                    <button id="clearDataBtn-mobile" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 mt-4">Clear All Saved Data</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        let repeaterData = [];
        let customMarkers = [];
        let isPlacingMarker = false;
        let lastAnalyzedTarget = null;
        let placementInfo = { mode: null, id: null }; 
        let previousDefaultRepeaterHeight = 30;
        let analysisController = null;
        const DEFAULT_LAT = 43.6532;
        const DEFAULT_LON = -79.3832;
        const K_FACTOR = 4 / 3;
        const EARTH_RADIUS_METERS = 6378137.0; 
        const EFFECTIVE_EARTH_RADIUS = EARTH_RADIUS_METERS * K_FACTOR;
        
        // --- DOM Element References ---
        let latInput, lonInput, userHeightInput, repeaterHeightInput, gpxUpload,
            addMarkerBtn, resetLocationBtn, customMarkerInputContainer, customMarkerNameInput,
            customMarkerFreqInput, filterStatusDiv, repeaterListDiv, customListDiv,
            losResultContainer, selectedRepeaterInfoDiv, pathLossResultContainer,
            profileChartCanvas, repeaterSearchInput, curvatureCheckbox, maxPathLossInput,
            runBatchAnalysisBtn, filterModeSelect, pathLossContainer;

        // --- Map and Chart Initialization ---
        let map;
        let userMarker, repeaterMarker, pathLine;
        let profileChart;
        let markerClusterGroup;
        let customMarkerLayer;
        const TILE_URL = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        const TILE_ATTRIBUTION = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            latInput = document.getElementById('latitude');
            lonInput = document.getElementById('longitude');
            userHeightInput = document.getElementById('user-height');
            repeaterHeightInput = document.getElementById('repeater-height');
            gpxUpload = document.getElementById('gpx-upload');
            addMarkerBtn = document.getElementById('addMarkerBtn');
            resetLocationBtn = document.getElementById('resetLocationBtn');
            customMarkerInputContainer = document.getElementById('custom-marker-input-container');
            customMarkerNameInput = document.getElementById('custom-marker-name');
            customMarkerFreqInput = document.getElementById('custom-marker-freq');
            filterStatusDiv = document.getElementById('filter-status');
            repeaterListDiv = document.getElementById('repeater-list');
            customListDiv = document.getElementById('custom-list');
            losResultContainer = document.getElementById('los-result-container');
            pathLossResultContainer = document.getElementById('path-loss-result-container');
            selectedRepeaterInfoDiv = document.getElementById('selected-repeater-info');
            profileChartCanvas = document.getElementById('profileChart');
            repeaterSearchInput = document.getElementById('repeater-search');
            curvatureCheckbox = document.getElementById('curvature-checkbox');
            maxPathLossInput = document.getElementById('max-path-loss-input');
            runBatchAnalysisBtn = document.getElementById('run-batch-analysis');
            filterModeSelect = document.getElementById('filter-mode-select');
            pathLossContainer = document.getElementById('path-loss-container');
            
            map = L.map('map').setView([DEFAULT_LAT, DEFAULT_LON], 9);
            L.tileLayer(TILE_URL, { attribution: TILE_ATTRIBUTION }).addTo(map);
            markerClusterGroup = L.markerClusterGroup({ maxClusterRadius: 20 });
            map.addLayer(markerClusterGroup);
            customMarkerLayer = L.layerGroup().addTo(map);

            setLocation(DEFAULT_LAT, DEFAULT_LON);
            requestUserGeolocation();
            loadFromLocalStorage();

            map.on('click', onMapClick);
            gpxUpload.addEventListener('change', handleFileUpload);
            addMarkerBtn.addEventListener('click', () => togglePlaceMarkerMode('custom'));
            resetLocationBtn.addEventListener('click', requestUserGeolocation);
            runBatchAnalysisBtn.addEventListener('click', runBatchAnalysis);
            maxPathLossInput.addEventListener('input', () => updateFilteredView(repeaterData, getCurrentCoords()));
            filterModeSelect.addEventListener('change', handleFilterModeChange);

            const reanalyzeInputs = [userHeightInput, curvatureCheckbox];
            reanalyzeInputs.forEach(input => {
                input.addEventListener('input', () => { 
                    if (lastAnalyzedTarget) analyzePath(lastAnalyzedTarget, getCurrentCoords()); 
                });
            });
            repeaterSearchInput.addEventListener('input', () => updateFilteredView(repeaterData, getCurrentCoords()));
            
            repeaterHeightInput.addEventListener('focus', (e) => {
                previousDefaultRepeaterHeight = parseFloat(e.target.value) || 30;
            });
            repeaterHeightInput.addEventListener('input', handleDefaultRepeaterHeightChange);
            
            ['desktop', 'mobile'].forEach(view => {
                document.getElementById(`saveSetBtn-${view}`).addEventListener('click', saveCurrentSet);
                document.getElementById(`deleteSetBtn-${view}`).addEventListener('click', () => {
                    document.getElementById(`delete-confirmation-${view}`).classList.remove('hidden');
                });
                document.getElementById(`confirmDeleteBtn-${view}`).addEventListener('click', deleteCurrentSet);
                document.getElementById(`cancelDeleteBtn-${view}`).addEventListener('click', () => {
                     document.getElementById(`delete-confirmation-${view}`).classList.add('hidden');
                });
                document.getElementById(`set-select-${view}`).addEventListener('change', loadSelectedSet);
                document.getElementById(`clearDataBtn-${view}`).addEventListener('click', clearLocalStorage);
            });

            handleFilterModeChange();
        });


        // --- Core Functions ---
        
        function handleFilterModeChange() {
            const filterMode = filterModeSelect.value;
            const isPathLossMode = filterMode === 'pathLoss';
            const filterControlsGrid = document.getElementById('filter-controls-grid');

            pathLossContainer.classList.toggle('hidden', !isPathLossMode);

            if (isPathLossMode) {
                filterControlsGrid.classList.add('grid-cols-2');
                filterControlsGrid.classList.remove('grid-cols-1');
            } else {
                filterControlsGrid.classList.remove('grid-cols-2');
                filterControlsGrid.classList.add('grid-cols-1');
            }

            updateFilteredView(repeaterData, getCurrentCoords());
        }

        function requestUserGeolocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    setLocation(position.coords.latitude, position.coords.longitude);
                }, () => {
                    console.warn('Could not retrieve user location. Using default.');
                });
            }
        }

        function setLocation(lat, lon) {
            latInput.value = lat.toFixed(5);
            lonInput.value = lon.toFixed(5);
            updateUserMarker(lat, lon);
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            repeaterListDiv.innerHTML = `<div class="p-3"><div class="flex items-center"><div class="loading-spinner !w-4 !h-4 mr-2"></div><span>Parsing GPX...</span></div></div>`;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    repeaterData = parseGPX(e.target.result);
                    repeaterData.forEach(r => {
                        delete r.pathLoss;
                        delete r.isVisible;
                    });
                    filterStatusDiv.textContent = `Loaded ${repeaterData.length} repeaters. Click "Analyze All Repeaters" to begin.`;
                    updateFilteredView(repeaterData, getCurrentCoords());
                } catch (error) {
                    filterStatusDiv.textContent = `Error parsing GPX: ${error.message}`;
                    repeaterListDiv.innerHTML = '<p class="p-3 text-red-500">Failed to parse GPX file. Please check format.</p>';
                }
            };
            reader.readAsText(file);
        }

        function parseGPX(gpxString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxString, "text/xml");
            const waypoints = xmlDoc.getElementsByTagName("wpt");
            const data = [];
            const defaultHeight = parseFloat(repeaterHeightInput.value) || 30;

            for (let i = 0; i < waypoints.length; i++) {
                const wpt = waypoints[i];
                const nameNode = wpt.getElementsByTagName("name")[0];
                const cmtNode = wpt.getElementsByTagName("cmt")[0];
                
                if (!nameNode || !cmtNode) continue;
                
                const nameStr = nameNode.textContent;
                const parts = nameStr.split(/\s+/);

                let callsign = parts[0] || 'N/A';
                let outputFreqStr = 'N/A';
                let offsetSign = 'N/A';
                let uplinkTone = 'N/A';

                const infoParts = parts.slice(1);
                let freqIndex = -1;

                for (let j = 0; j < infoParts.length; j++) {
                    const part = infoParts[j];
                    const num = parseFloat(part);
                    if (!isNaN(num) && num > 20) {
                        outputFreqStr = part.replace(/[+-]$/, '');
                        if (part.endsWith('+') || part.endsWith('-')) {
                            offsetSign = part.slice(-1);
                        }
                        freqIndex = j;
                        break;
                    }
                }

                if (freqIndex !== -1) {
                    infoParts.splice(freqIndex, 1);
                }

                for (const part of infoParts) {
                    if (part === '+' || part === '-') {
                        offsetSign = part;
                    } else {
                        uplinkTone = part;
                    }
                }

                const outputFreq = parseFloat(outputFreqStr);
                let inputFreq = 'N/A';

                if (!isNaN(outputFreq) && (offsetSign === '+' || offsetSign === '-')) {
                    let standardOffset = 0.6;
                    if (outputFreq >= 440 && outputFreq <= 450) {
                        standardOffset = 5.0;
                    } else if (outputFreq >= 222 && outputFreq <= 225) {
                        standardOffset = 1.6;
                    }

                    if (offsetSign === '+') {
                        inputFreq = (outputFreq + standardOffset).toFixed(4);
                    } else {
                        inputFreq = (outputFreq - standardOffset).toFixed(4);
                    }
                }

                data.push({
                    id: `repeater-${i}`,
                    lat: parseFloat(wpt.getAttribute("lat")),
                    lon: parseFloat(wpt.getAttribute("lon")),
                    callsign: callsign,
                    outputFreq: outputFreqStr,
                    inputFreq: inputFreq,
                    offset: offsetSign,
                    uplinkTone: uplinkTone,
                    antennaHeight: defaultHeight,
                    location: cmtNode.textContent.replace(callsign, '').replace('OPEN', '').trim()
                });
            }
            return data;
        }
        
        const delay = ms => new Promise(res => setTimeout(res, ms));

        async function runBatchAnalysis() {
            if (analysisController) {
                analysisController.abort();
            }
            analysisController = new AbortController();
            const signal = analysisController.signal;

            if (repeaterData.length === 0) {
                filterStatusDiv.textContent = "Please upload a repeater GPX file first.";
                setTimeout(() => filterStatusDiv.textContent = '', 3000);
                return;
            }

            const userCoords = getCurrentCoords();
            let completedCount = 0;
            const repeatersToAnalyze = repeaterData.filter(r => !r.locationUnknown);
            const totalRepeaters = repeatersToAnalyze.length;
            
            const startTime = Date.now();
            
            repeaterData.forEach(r => {
                delete r.pathLoss;
                delete r.isVisible;
            });
            updateFilteredView(repeaterData, userCoords);

            const concurrencyLimit = 5;
            const queue = [...repeatersToAnalyze];
            
            const worker = async () => {
                while(queue.length > 0) {
                    if (signal.aborted) return;
                    const repeater = queue.shift();
                    if (!repeater) continue;

                    const result = await getPathAnalysisForRepeater(repeater, userCoords);
                    if (signal.aborted) return;

                    repeater.pathLoss = result.pathLoss;
                    repeater.isVisible = result.isVisible;
                    completedCount++;
                    
                    updateFilteredView(repeaterData, userCoords);
                    
                    const elapsedTime = Date.now() - startTime;
                    const avgTime = elapsedTime / completedCount;
                    const remainingTime = avgTime * (totalRepeaters - completedCount);
                    const formattedTime = formatRemainingTime(remainingTime);
                    const reachableCount = getFilteredData(repeaterData).length;
                    
                    filterStatusDiv.innerHTML = `<div class="flex items-center"><div class="loading-spinner !w-4 !h-4 mr-2"></div><span>Analyzed ${completedCount} of ${totalRepeaters}... Found ${reachableCount} reachable. (Est. ${formattedTime} left)</span></div>`;
                }
            };

            const workers = Array(concurrencyLimit).fill(null).map(worker);
            
            try {
                await Promise.all(workers);
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Batch analysis was cancelled.');
                    filterStatusDiv.textContent = 'Analysis cancelled.';
                    repeaterData.forEach(r => {
                        delete r.pathLoss;
                        delete r.isVisible;
                    });
                    updateFilteredView(repeaterData, userCoords);
                    return;
                }
                throw error;
            }

            if (signal.aborted) return;

            const reachableCount = getFilteredData(repeaterData).length;
            filterStatusDiv.textContent = `Analysis complete. Found ${reachableCount} of ${totalRepeaters} repeaters matching criteria.`;
            updateFilteredView(repeaterData, userCoords);
        }

        async function getPathAnalysisForRepeater(repeater, userCoords) {
            try {
                const initialPoints = getPointsOnPath(userCoords, { lat: repeater.lat, lon: repeater.lon }, 100);
                const elevationProfile = await getElevationProfile(initialPoints);
                const userAntennaHeight = parseFloat(userHeightInput.value) || 10;
                const repeaterAntennaHeight = parseFloat(repeater.antennaHeight) || parseFloat(repeaterHeightInput.value) || 30;
                const frequencyMHz = parseFloat(repeater.outputFreq || repeater.frequency) || 146.520;
                const distanceKm = getDistance(userCoords, repeater);

                const { isVisible } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight);
                const fspl = calculateFreeSpacePathLoss(distanceKm, frequencyMHz);
                let totalPathLoss = fspl;

                if (!isVisible) {
                    const deygoutResult = calculateDeygoutDiffractionLoss(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);
                    totalPathLoss += deygoutResult.totalLoss;
                }
                
                return { pathLoss: totalPathLoss, isVisible: isVisible };
            } catch (error) {
                console.error(`Failed to analyze path loss for ${repeater.callsign}:`, error);
                return { pathLoss: Infinity, isVisible: false };
            }
        }

        function formatRemainingTime(ms) {
            if (ms < 1000) return "< 1s";
            let totalSeconds = Math.round(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            }
            return `${seconds}s`;
        }
        
        function getFilteredData(allRepeaters) {
            const searchTerm = repeaterSearchInput.value.toLowerCase();
            const filterMode = filterModeSelect.value;
            const maxPathLoss = parseFloat(maxPathLossInput.value);
            
            let filtered = [...allRepeaters];

            if (searchTerm) {
                filtered = filtered.filter(r => 
                    r.callsign.toLowerCase().includes(searchTerm) ||
                    (r.outputFreq && r.outputFreq.includes(searchTerm)) ||
                    (r.inputFreq && r.inputFreq.includes(searchTerm)) ||
                    r.location.toLowerCase().includes(searchTerm)
                );
            }
            
            if (filterMode === 'none') {
                return filtered;
            }

            const analysisHasRun = allRepeaters.some(r => r.pathLoss !== undefined || r.isVisible !== undefined);
            if (!analysisHasRun && filterMode !== 'none') {
                return []; // Don't show any if analysis is required but not run
            }

            if (filterMode === 'pathLoss' && !isNaN(maxPathLoss)) {
                filtered = filtered.filter(r => typeof r.pathLoss === 'number' && r.pathLoss <= maxPathLoss);
            } else if (filterMode === 'los') {
                filtered = filtered.filter(r => r.isVisible);
            }

            return filtered;
        }

        function updateFilteredView(allRepeaters, userCoords) {
            const filteredData = getFilteredData(allRepeaters);
            const filterMode = filterModeSelect.value;
            const analysisHasRun = allRepeaters.some(r => r.pathLoss !== undefined || r.isVisible !== undefined);

            filteredData.sort((a, b) => {
                if (filterMode === 'pathLoss' && analysisHasRun) {
                    const pa = (typeof a.pathLoss === 'number') ? a.pathLoss : Infinity;
                    const pb = (typeof b.pathLoss === 'number') ? b.pathLoss : Infinity;
                    return pa - pb;
                }
                return getDistance(userCoords, a) - getDistance(userCoords, b);
            });

            repeaterListDiv.innerHTML = '';
            markerClusterGroup.clearLayers();

            if (filteredData.length === 0) {
                 repeaterListDiv.innerHTML = '<p class="p-3 text-gray-500">No repeaters match the current filters.</p>';
            }

            filteredData.forEach(repeater => {
                const distance = getDistance(userCoords, repeater).toFixed(1);
                
                let pathLossHTML = '';
                if (typeof repeater.pathLoss === 'number') {
                    const lossColor = repeater.pathLoss > 160 ? 'text-red-500' : repeater.pathLoss > 140 ? 'text-yellow-600' : 'text-green-600';
                    pathLossHTML = `<p class="text-sm font-medium ${lossColor}">Loss: ${repeater.pathLoss.toFixed(1)} dB</p>`;
                } else if (repeater.isVisible === true) {
                    pathLossHTML = `<p class="text-sm font-medium text-green-600">Clear LOS</p>`;
                } else if (repeater.isVisible === false) {
                    pathLossHTML = `<p class="text-sm font-medium text-red-500">Obstructed</p>`;
                }

                const item = document.createElement('div');
                item.className = 'p-3 border rounded-lg hover:bg-gray-100';
                item.innerHTML = `
                    <div class="flex justify-between items-start cursor-pointer" data-repeater-id="${repeater.id}">
                        <div>
                            <p class="font-bold">${repeater.callsign}</p>
                            <p class="text-sm text-gray-600">${repeater.location}</p>
                        </div>
                        <div class="text-right">
                            <p class="text-sm font-medium text-gray-800">${distance} km</p>
                            ${pathLossHTML}
                        </div>
                    </div>
                    <div class="mt-2 text-xs text-gray-700 grid grid-cols-2 gap-x-4 gap-y-1">
                        <span><span class="font-semibold">Output:</span> ${repeater.outputFreq} (${repeater.offset})</span>
                        <span><span class="font-semibold">Input:</span> ${repeater.inputFreq}</span>
                        ${repeater.uplinkTone !== 'N/A' ? `<span><span class="font-semibold">Tone:</span> ${repeater.uplinkTone}</span>` : ''}
                        <div class="col-span-2 mt-1">
                            <label for="height-${repeater.id}" class="text-xs font-medium">Antenna Ht (m):</label>
                            <input type="number" id="height-${repeater.id}" value="${repeater.antennaHeight}" class="w-20 ml-1 px-1 py-0.5 text-xs border border-gray-300 rounded">
                        </div>
                    </div>
                `;
                item.querySelector(`[data-repeater-id="${repeater.id}"]`).onclick = () => analyzePath(repeater, getCurrentCoords());
                
                const heightInput = item.querySelector(`#height-${repeater.id}`);
                heightInput.addEventListener('input', (e) => {
                    const newHeight = parseFloat(e.target.value);
                    const targetRepeater = repeaterData.find(r => r.id === repeater.id);
                    if (targetRepeater && !isNaN(newHeight)) {
                        targetRepeater.antennaHeight = newHeight;
                        if (lastAnalyzedTarget && lastAnalyzedTarget.id === repeater.id) {
                            analyzePath(targetRepeater, getCurrentCoords());
                        }
                    }
                });

                repeaterListDiv.appendChild(item);
                addRepeaterMarkerToMap(repeater);
            });
        }
        
        function addRepeaterMarkerToMap(repeater) {
            const marker = L.marker([repeater.lat, repeater.lon], { draggable: true })
                .bindPopup(`<b>${repeater.callsign}</b><br>${repeater.location}<br>${repeater.outputFreq} MHz<br><button class="mt-2 p-1 bg-indigo-500 text-white rounded text-xs" onclick='analyzePathFromPopup(${JSON.stringify(repeater)})'>Check Path</button>`);
            
            marker.on('dragend', (event) => {
                const newCoords = event.target.getLatLng();
                const targetRepeater = repeaterData.find(r => r.id === repeater.id);
                if (targetRepeater) {
                    targetRepeater.lat = newCoords.lat;
                    targetRepeater.lon = newCoords.lng;
                    targetRepeater.location = `Custom Position (${newCoords.lat.toFixed(3)}, ${newCoords.lng.toFixed(3)})`;
                }
                repeaterData.forEach(r => {
                    delete r.pathLoss;
                    delete r.isVisible;
                });
                updateFilteredView(repeaterData, getCurrentCoords());
                if (lastAnalyzedTarget && lastAnalyzedTarget.id === repeater.id) {
                    analyzePath(repeater, getCurrentCoords());
                }
            });

            markerClusterGroup.addLayer(marker);
        }

        function analyzePathFromPopup(repeater) {
            const fullRepeaterData = repeaterData.find(r => r.id === repeater.id);
            if(fullRepeaterData) {
                analyzePath(fullRepeaterData, getCurrentCoords());
            }
            map.closePopup();
        }

        function updateUserMarker(lat, lon) {
            if (userMarker) {
                map.removeLayer(userMarker);
            }
            userMarker = L.marker([lat, lon], {
                draggable: true,
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                })
            }).addTo(map);

            userMarker.bindPopup('Your Location').openPopup();
            map.setView([lat, lon], 9);

            userMarker.on('dragend', function(event) {
                if (analysisController) {
                    analysisController.abort();
                }
                const newCoords = event.target.getLatLng();
                const standardizedCoords = { lat: newCoords.lat, lon: newCoords.lng };
                latInput.value = standardizedCoords.lat.toFixed(5);
                lonInput.value = standardizedCoords.lon.toFixed(5);
                
                repeaterData.forEach(r => {
                    delete r.pathLoss;
                    delete r.isVisible;
                });
                filterStatusDiv.textContent = "Location changed. Please re-run analysis.";
                
                updateFilteredView(repeaterData, standardizedCoords);
                displayCustomMarkers();
                if (lastAnalyzedTarget) {
                    analyzePath(lastAnalyzedTarget, standardizedCoords);
                }
            });
        }
        
        function getCurrentCoords() {
            return {
                lat: parseFloat(latInput.value),
                lon: parseFloat(lonInput.value)
            };
        }

        async function analyzePath(target, userCoords) {
            lastAnalyzedTarget = target;
            displaySelectedRepeaterInfo(target);
            losResultContainer.innerHTML = '<div class="flex justify-center items-center"><div class="loading-spinner"></div><p class="ml-4">Analyzing terrain...</p></div>';
            pathLossResultContainer.innerHTML = '<p class="text-gray-500">Awaiting line-of-sight result...</p>';
            if (profileChart) profileChart.destroy();

            if (repeaterMarker) map.removeLayer(repeaterMarker);
            repeaterMarker = L.marker([target.lat, target.lon], {
                 icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                })
            }).addTo(map);
            repeaterMarker.options.customId = target.id;
            repeaterMarker.bindPopup(`<b>${target.callsign || target.name}</b>`).openPopup();

            const initialPoints = getPointsOnPath(userCoords, { lat: target.lat, lon: target.lon }, 100);
            
            try {
                let elevationProfile = await getElevationProfile(initialPoints);
                const userAntennaHeight = parseFloat(userHeightInput.value) || 10;
                let repeaterAntennaHeight = parseFloat(target.antennaHeight) || parseFloat(repeaterHeightInput.value) || 30;
                
                let { isVisible, obstructionPoint } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight);
                let allObstructions = [];

                if (isVisible) {
                    const closeApproachSegments = findCloseApproachSegments(elevationProfile, userAntennaHeight, repeaterAntennaHeight, 20);
                    if (closeApproachSegments.length > 0) {
                        losResultContainer.innerHTML = '<div class="flex justify-center items-center"><div class="loading-spinner"></div><p class="ml-4">Refining path analysis...</p></div>';
                        elevationProfile = await refineElevationProfile(elevationProfile, initialPoints, closeApproachSegments);
                        ({ isVisible, obstructionPoint } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight));
                    }
                }

                displayLosResult(isVisible, obstructionPoint, userCoords, target);
                
                const distanceKm = getDistance(userCoords, target);
                const frequencyMHz = parseFloat(target.outputFreq || target.frequency) || 146.520;
                
                const fspl = calculateFreeSpacePathLoss(distanceKm, frequencyMHz);
                let totalPathLoss = fspl;
                let diffractionLoss = 0;

                if (!isVisible) {
                    const deygoutResult = calculateDeygoutDiffractionLoss(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);
                    diffractionLoss = deygoutResult.totalLoss;
                    allObstructions = deygoutResult.obstructions;
                    totalPathLoss += diffractionLoss;
                } else {
                    allObstructions = [];
                }

                displayPathLossResult(totalPathLoss, fspl, diffractionLoss, isVisible, target);

                drawProfileChart(elevationProfile, userAntennaHeight, repeaterAntennaHeight, isVisible, allObstructions);
                drawPathOnMap(initialPoints, isVisible);

            } catch (error) {
                console.error("Error during analysis:", error);
                losResultContainer.innerHTML = `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                    <strong class="font-bold">Error!</strong>
                    <span class="block sm:inline">Could not fetch elevation data. ${error.message}</span>
                </div>`;
            }
        }

        function getPointsOnPath(start, end, numPoints = 100) {
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const t = i / (numPoints - 1);
                points.push({
                    lat: start.lat + t * (end.lat - start.lat),
                    lon: start.lon + t * (end.lon - start.lon)
                });
            }
            return points;
        }

        async function getElevationProfile(points) {
            if (points.length === 0) return [];
            const start = points[0];
            const end = points[points.length - 1];
            
            const isCanadianPath = (start.lat > 41 && end.lat > 41 && start.lon < -60 && end.lon < -60);

            let apiUrl;
            let isNrCan = false;
            if (isCanadianPath) {
                const path = `LINESTRING(${start.lon} ${start.lat}, ${end.lon} ${end.lat})`;
                apiUrl = `https://geogratis.gc.ca/services/elevation/cdem/profile?path=${encodeURIComponent(path)}&steps=${points.length - 2}`;
                isNrCan = true;
            } else {
                const latitudes = points.map(p => p.lat.toFixed(5)).join(',');
                const longitudes = points.map(p => p.lon.toFixed(5)).join(',');
                apiUrl = `https://api.open-meteo.com/v1/elevation?latitude=${latitudes}&longitude=${longitudes}`;
            }
            
            let response;
            const maxRetries = 3;
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                response = await fetch(apiUrl);
                if (response.ok) break;
                if (response.status === 429 && attempt < maxRetries) {
                    const retryAfter = attempt * 1000;
                    console.warn(`Rate limited. Retrying in ${retryAfter}ms...`);
                    await delay(retryAfter);
                } else {
                    throw new Error(`Elevation API request failed. Status: ${response.status}`);
                }
            }
            
            const data = await response.json();

            if (isNrCan) {
                if (!data || !Array.isArray(data)) throw new Error('Invalid data received from NRCan API.');
                return data.map((p, i) => ({
                    elevation: p.altitude,
                    location: { lat: p.geometry.coordinates[1], lon: p.geometry.coordinates[0] },
                    originalIndex: i
                }));
            } else {
                if (!data.elevation) throw new Error('Invalid data received from Open-Meteo API.');
                return data.elevation.map((elevation, index) => ({
                    elevation: elevation,
                    location: { lat: points[index].lat, lon: points[index].lon },
                    originalIndex: index
                }));
            }
        }

        function calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight) {
            const worstObstruction = findWorstObstruction(elevationProfile, userAntennaHeight, repeaterAntennaHeight);
            return {
                isVisible: !worstObstruction,
                obstructionPoint: worstObstruction
            };
        }
        
        function calculateFreeSpacePathLoss(distanceKm, frequencyMHz) {
            if (distanceKm <= 0 || frequencyMHz <= 0) {
                return 0;
            }
            const pathLoss = 20 * Math.log10(distanceKm) + 20 * Math.log10(frequencyMHz) + 32.44;
            return pathLoss;
        }

        function calculateKnifeEdgeDiffractionLoss(h, d1, d2, frequencyMHz) {
            const c = 299792458;
            const frequencyHz = frequencyMHz * 1e6;
            const lambda = c / frequencyHz;

            if (h <= 0 || d1 <= 0 || d2 <= 0) return 0;

            const v = h * Math.sqrt((2 / lambda) * ((1 / d1) + (1 / d2)));
            const diffractionLossDb = 6.9 + 20 * Math.log10(Math.sqrt(Math.pow(v - 0.1, 2) + 1) + v - 0.1);
            
            return diffractionLossDb > 0 ? diffractionLossDb : 0;
        }

        function findWorstObstruction(pathSegment, startAntennaHeight, endAntennaHeight) {
            if (!pathSegment || pathSegment.length < 2) {
                return null;
            }
            const applyCurvature = document.getElementById('curvature-checkbox').checked;
            const totalDistance = getDistance(pathSegment[0].location, pathSegment[pathSegment.length - 1].location) * 1000;

            const startElevation = pathSegment[0].elevation + startAntennaHeight;
            const endElevation = pathSegment[pathSegment.length - 1].elevation + endAntennaHeight;

            let worstObstruction = null;
            let maxH = -Infinity;

            for (let i = 1; i < pathSegment.length - 1; i++) {
                const intermediatePoint = pathSegment[i];
                const fraction = i / (pathSegment.length - 1);
                
                const terrainElevation = intermediatePoint.elevation;
                const straightLosHeight = startElevation + fraction * (endElevation - startElevation);
                
                let effectiveLosHeight = straightLosHeight;
                if (applyCurvature) {
                    const d1 = totalDistance * fraction;
                    const d2 = totalDistance - d1;
                    const curvatureDrop = (d1 * d2) / (2 * EFFECTIVE_EARTH_RADIUS);
                    effectiveLosHeight -= curvatureDrop;
                }

                const h = terrainElevation - effectiveLosHeight;

                if (h > maxH) {
                    maxH = h;
                    worstObstruction = {
                        ...intermediatePoint,
                        h: h,
                        indexInSegment: i
                    };
                }
            }

            return maxH > 0 ? worstObstruction : null;
        }

        function calculateDeygoutDiffractionLoss(pathProfile, startHeight, endHeight, frequencyMHz) {
            function getLossAndObstructionsRecursive(subPath, subStartHeight, subEndHeight) {
                const mainObstruction = findWorstObstruction(subPath, subStartHeight, subEndHeight);

                if (!mainObstruction) {
                    return { loss: 0, obstructions: [] };
                }

                const totalSubPathDistance = getDistance(subPath[0].location, subPath[subPath.length - 1].location) * 1000;
                const d1 = getDistance(subPath[0].location, mainObstruction.location) * 1000;
                const d2 = totalSubPathDistance - d1;
                
                const mainLoss = calculateKnifeEdgeDiffractionLoss(mainObstruction.h, d1, d2, frequencyMHz);

                let results1 = { loss: 0, obstructions: [] };
                const path1 = subPath.slice(0, mainObstruction.indexInSegment + 1);
                if (path1.length > 2) {
                    results1 = getLossAndObstructionsRecursive(path1, subStartHeight, 0);
                }
                
                let results2 = { loss: 0, obstructions: [] };
                const path2 = subPath.slice(mainObstruction.indexInSegment);
                if (path2.length > 2) {
                    results2 = getLossAndObstructionsRecursive(path2, 0, subEndHeight);
                }
                
                return {
                    loss: mainLoss + results1.loss + results2.loss,
                    obstructions: [mainObstruction, ...results1.obstructions, ...results2.obstructions]
                };
            }

            const results = getLossAndObstructionsRecursive(pathProfile, startHeight, endHeight);
            return { totalLoss: results.loss, obstructions: results.obstructions };
        }


        function findCloseApproachSegments(elevationProfile, userAntennaHeight, repeaterAntennaHeight, threshold) {
            const segments = [];
            if (elevationProfile.length < 2) return segments;
            const applyCurvature = document.getElementById('curvature-checkbox').checked;
            const totalDistance = getDistance(elevationProfile[0].location, elevationProfile[elevationProfile.length - 1].location) * 1000;

            const startElevation = elevationProfile[0].elevation + userAntennaHeight;
            const endElevation = elevationProfile[elevationProfile.length - 1].elevation + repeaterAntennaHeight;
            
            let currentSegment = null;

            for (let i = 1; i < elevationProfile.length - 1; i++) {
                const point = elevationProfile[i];
                const fraction = i / (elevationProfile.length - 1);
                
                const terrainElevation = point.elevation;
                const straightLosHeight = startElevation + fraction * (endElevation - startElevation);
                let effectiveLosHeight = straightLosHeight;
                
                if (applyCurvature) {
                    const d1 = totalDistance * fraction;
                    const d2 = totalDistance - d1;
                    const curvatureDrop = (d1 * d2) / (2 * EFFECTIVE_EARTH_RADIUS);
                    effectiveLosHeight -= curvatureDrop;
                }
                
                const clearance = effectiveLosHeight - terrainElevation;

                if (clearance > 0 && clearance < threshold) {
                    if (!currentSegment) {
                        currentSegment = { start: Math.max(0, i - 1) };
                    }
                } else {
                    if (currentSegment) {
                        currentSegment.end = Math.min(elevationProfile.length - 1, i);
                        segments.push(currentSegment);
                        currentSegment = null;
                    }
                }
            }
            if (currentSegment) {
                currentSegment.end = elevationProfile.length - 1;
                segments.push(currentSegment);
            }
            return segments;
        }

        async function refineElevationProfile(initialProfile, initialPoints, segments) {
            let refinedProfile = [...initialProfile];
            let offset = 0;

            for (const segment of segments) {
                const startPoint = initialPoints[segment.start];
                const endPoint = initialPoints[segment.end];
                
                const refinedPoints = getPointsOnPath(startPoint, endPoint, 50);
                const refinedSegmentProfile = await getElevationProfile(refinedPoints);

                const pointsToRemove = segment.end - segment.start + 1;
                refinedProfile.splice(segment.start + offset, pointsToRemove, ...refinedSegmentProfile);
                
                offset += refinedSegmentProfile.length - pointsToRemove;
            }
            return refinedProfile;
        }

        function displaySelectedRepeaterInfo(target) {
            selectedRepeaterInfoDiv.innerHTML = `
                <div class="text-left">
                    <p class="font-bold text-lg">${target.callsign}</p>
                    <p class="text-sm text-gray-600">${target.location}</p>
                    <div class="mt-2 text-sm text-gray-800 grid grid-cols-2 gap-x-4 gap-y-1">
                        <span><span class="font-semibold">Frequency:</span> ${target.outputFreq || target.frequency} MHz</span>
                        <span><span class="font-semibold">Antenna Ht:</span> ${target.antennaHeight} m</span>
                    </div>
                </div>
            `;
        }

        function displayLosResult(isVisible, obstructionPoint, userCoords, target) {
            const distance = getDistance(userCoords, target).toFixed(2);
            let resultHTML;
            if (isVisible) {
                resultHTML = `<div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4">
                                    <p class="font-bold text-xl">Line-of-Sight is CLEAR!</p>
                                    <p>The path to ${target.callsign} (${distance} km) appears to be unobstructed by terrain.</p>
                                </div>`;
            } else {
                const obstructionDist = (distance * (obstructionPoint ? obstructionPoint.originalIndex / (100 - 1) : 0)).toFixed(2);
                resultHTML = `<div class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4">
                                    <p class="font-bold text-xl">Line-of-Sight is OBSTRUCTED</p>
                                    <p>The path to ${target.callsign} (${distance} km) is blocked by terrain.</p>
                                    ${obstructionPoint ? `<p>The primary obstruction is approximately ${obstructionDist} km from your location.</p>` : ''}
                                </div>`;
            }
            losResultContainer.innerHTML = resultHTML;
        }

        function displayPathLossResult(totalPathLoss, fspl, diffractionLoss, isVisible, target) {
            let resultHTML;
            if (isVisible) {
                resultHTML = `<div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4">
                                    <p class="font-bold text-xl">Free-Space Path Loss (FSPL)</p>
                                    <p>Estimated loss to ${target.callsign}: <span class="font-bold text-2xl">${totalPathLoss.toFixed(2)} dB</span></p>
                                    <p class="text-xs mt-2">Note: This is an ideal calculation for a clear path and does not account for atmospheric conditions, foliage, buildings, or antenna gain.</p>
                                  </div>`;
            } else {
                resultHTML = `<div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4">
                                    <p class="font-bold text-xl">Total Path Loss (Estimated)</p>
                                    <p>Estimated total loss to ${target.callsign}: <span class="font-bold text-2xl">${totalPathLoss.toFixed(2)} dB</span></p>
                                    <div class="mt-2 text-sm">
                                        <p>Free-Space Path Loss: ${fspl.toFixed(2)} dB</p>
                                        <p>+ Total Diffraction Loss: ${diffractionLoss.toFixed(2)} dB</p>
                                    </div>
                                    <p class="text-xs mt-2">Note: Diffraction loss is estimated using the Deygout method for multiple terrain obstructions. This does not account for other real-world factors.</p>
                                  </div>`;
            }
            pathLossResultContainer.innerHTML = resultHTML;
        }
        
        function drawProfileChart(elevationData, userAntennaHeight, repeaterAntennaHeight, isVisible, allObstructions) {
            if (profileChart) {
                profileChart.destroy();
            }
            const applyCurvature = document.getElementById('curvature-checkbox').checked;
            const totalDistance = getDistance(elevationData[0].location, elevationData[elevationData.length - 1].location) * 1000;

            const labels = elevationData.map((_, i) => (getDistance(elevationData[0].location, elevationData[i].location)).toFixed(1) + ' km');
            
            const terrainData = elevationData.map(p => p.elevation);

            const startElevation = elevationData[0].elevation + userAntennaHeight;
            const endElevation = elevationData[elevationData.length - 1].elevation + repeaterAntennaHeight;
            
            const losData = elevationData.map((_, i) => {
                const fraction = i / (elevationData.length - 1);
                const straightLosHeight = startElevation + fraction * (endElevation - startElevation);
                
                if (applyCurvature) {
                    const d1 = totalDistance * fraction;
                    const d2 = totalDistance - d1;
                    const curvatureDrop = (d1 * d2) / (2 * EFFECTIVE_EARTH_RADIUS);
                    return straightLosHeight - curvatureDrop;
                }
                return straightLosHeight;
            });

            const datasets = [{
                label: 'Terrain Profile',
                data: terrainData,
                borderColor: 'rgb(139, 69, 19)',
                backgroundColor: 'rgba(139, 69, 19, 0.2)',
                fill: true,
                pointRadius: 0,
                borderWidth: 2
            }, {
                label: applyCurvature ? 'Line of Sight (Curved Path)' : 'Line of Sight',
                data: losData,
                borderColor: isVisible ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)',
                fill: false,
                pointRadius: 0,
                borderWidth: 3,
                borderDash: [5, 5]
            }];
            
            if (allObstructions && allObstructions.length > 0) {
                const obstructionPoints = allObstructions.map((obs, index) => ({
                    x: obs.originalIndex,
                    y: obs.elevation
                }));

                datasets.push({
                    label: 'Obstructions',
                    data: obstructionPoints,
                    backgroundColor: 'rgb(239, 68, 68)',
                    pointRadius: 6,
                    pointStyle: 'crossRot',
                    type: 'scatter'
                });
            }

            const ctx = profileChartCanvas.getContext('2d');
            profileChart = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Elevation Profile' },
                        legend: { position: 'top' },
                        tooltip: { callbacks: {
                            title: (context) => `Distance: ${context[0].label}`,
                            label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(1)} m`
                        }}
                    },
                    scales: {
                        x: { title: { display: true, text: 'Path from You to Target' } },
                        y: { title: { display: true, text: 'Elevation (meters)' } }
                    }
                }
            });
        }

        function drawPathOnMap(points, isVisible) {
            if (pathLine) map.removeLayer(pathLine);
            const latLngs = points.map(p => [p.lat, p.lon]);
            pathLine = L.polyline(latLngs, { color: isVisible ? 'green' : 'red', weight: 4, opacity: 0.8 }).addTo(map);
            map.fitBounds(pathLine.getBounds().pad(0.1));
        }

        function getDistance(coords1, coords2) {
            const R = 6371; // km
            const dLat = (coords2.lat - coords1.lat) * Math.PI / 180;
            const dLon = (coords2.lon - coords1.lon) * Math.PI / 180;
            const lat1 = coords1.lat * Math.PI / 180;
            const lat2 = coords2.lat * Math.PI / 180;

            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            return R * c;
        }
        
        window.analyzePathFromPopup = analyzePathFromPopup;

        function togglePlaceMarkerMode(mode, id = null) {
            isPlacingMarker = !isPlacingMarker;
            placementInfo.mode = isPlacingMarker ? mode : null;
            placementInfo.id = id;
            
            const mapContainer = document.getElementById('map');
            if (isPlacingMarker) {
                mapContainer.classList.add('crosshair-cursor');
                addMarkerBtn.textContent = 'Cancel Placement';
                addMarkerBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                addMarkerBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                if (placementInfo.mode === 'custom') {
                    customMarkerInputContainer.classList.remove('hidden');
                }
            } else {
                mapContainer.classList.remove('crosshair-cursor');
                addMarkerBtn.textContent = 'Place Custom Marker';
                addMarkerBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                addMarkerBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                customMarkerInputContainer.classList.add('hidden');
            }
        }

        function onMapClick(e) {
            if (!isPlacingMarker) return;
            
            if (placementInfo.mode === 'custom') {
                const name = customMarkerNameInput.value.trim() || `Custom Marker ${customMarkers.length + 1}`;
                const newMarkerData = {
                    id: `custom-${Date.now()}`,
                    callsign: name,
                    lat: e.latlng.lat,
                    lon: e.latlng.lng,
                    location: `Custom Marker (${e.latlng.lat.toFixed(3)}, ${e.latlng.lng.toFixed(3)})`,
                    antennaHeight: parseFloat(repeaterHeightInput.value) || 30,
                    frequency: parseFloat(customMarkerFreqInput.value) || 146.520
                };
                customMarkers.push(newMarkerData);
                displayCustomMarkers();
                customMarkerNameInput.value = '';
            } else if (placementInfo.mode === 'repeater') {
                const repeater = repeaterData.find(r => r.id === placementInfo.id);
                if (repeater) {
                    repeater.lat = e.latlng.lat;
                    repeater.lon = e.latlng.lng;
                    delete repeater.locationUnknown;
                    updateFilteredView(repeaterData, getCurrentCoords());
                }
            }
            
            togglePlaceMarkerMode(null);
        }

        function displayCustomMarkers() {
            customListDiv.innerHTML = '';
            customMarkerLayer.clearLayers();

            if (customMarkers.length === 0) {
                customListDiv.innerHTML = '<p class="p-3 text-gray-500">Click "Place Custom Marker" to add locations.</p>';
            }

            customMarkers.forEach(markerData => {
                const userCoords = getCurrentCoords();
                const distance = getDistance(userCoords, markerData).toFixed(1);

                const item = document.createElement('div');
                item.className = 'p-3 border rounded-lg hover:bg-gray-100';
                item.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="flex-grow cursor-pointer" data-id="${markerData.id}">
                            <p class="font-bold">${markerData.callsign}</p>
                            <p class="text-sm text-gray-600">${markerData.location} (${distance} km)</p>
                        </div>
                        <button class="delete-custom-marker text-red-500 hover:text-red-700 font-bold ml-2 p-1">&times;</button>
                    </div>
                     <div class="mt-1 grid grid-cols-2 gap-x-4">
                        <div>
                            <label for="height-${markerData.id}" class="text-xs font-medium">Antenna Ht (m):</label>
                            <input type="number" id="height-${markerData.id}" value="${markerData.antennaHeight}" class="w-full mt-1 px-1 py-0.5 text-xs border border-gray-300 rounded">
                        </div>
                        <div>
                            <label for="freq-${markerData.id}" class="text-xs font-medium">Frequency (MHz):</label>
                            <input type="number" id="freq-${markerData.id}" value="${markerData.frequency}" class="w-full mt-1 px-1 py-0.5 text-xs border border-gray-300 rounded">
                        </div>
                    </div>
                `;
                item.querySelector('.flex-grow').onclick = () => analyzePath(markerData, userCoords);
                item.querySelector('.delete-custom-marker').onclick = (e) => {
                    e.stopPropagation();
                    deleteCustomMarker(markerData.id);
                };

                const heightInput = item.querySelector(`#height-${markerData.id}`);
                heightInput.addEventListener('input', (e) => {
                    const newHeight = parseFloat(e.target.value);
                    const targetMarker = customMarkers.find(m => m.id === markerData.id);
                    if (targetMarker && !isNaN(newHeight)) {
                        targetMarker.antennaHeight = newHeight;
                        if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerData.id) {
                            analyzePath(targetMarker, getCurrentCoords());
                        }
                    }
                });
                
                const freqInput = item.querySelector(`#freq-${markerData.id}`);
                freqInput.addEventListener('input', (e) => {
                    const newFreq = parseFloat(e.target.value);
                    const targetMarker = customMarkers.find(m => m.id === markerData.id);
                    if (targetMarker && !isNaN(newFreq)) {
                        targetMarker.frequency = newFreq;
                        if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerData.id) {
                            analyzePath(targetMarker, getCurrentCoords());
                        }
                    }
                });

                customListDiv.appendChild(item);

                const marker = L.marker([markerData.lat, markerData.lon], {
                    draggable: true,
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                    })
                }).addTo(customMarkerLayer);
                
                marker.on('dragend', (event) => {
                    const newCoords = event.target.getLatLng();
                    markerData.lat = newCoords.lat;
                    markerData.lon = newCoords.lng;
                    markerData.location = `Custom Marker (${newCoords.lat.toFixed(3)}, ${newCoords.lng.toFixed(3)})`;
                    displayCustomMarkers();
                    if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerData.id) {
                        analyzePath(markerData, getCurrentCoords());
                    }
                });
            });
        }
        
        function deleteCustomMarker(markerId) {
            const index = customMarkers.findIndex(m => m.id === markerId);
            if (index > -1) {
                if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerId) {
                    lastAnalyzedTarget = null;
                    if (repeaterMarker) map.removeLayer(repeaterMarker);
                    repeaterMarker = null;
                    if (pathLine) map.removeLayer(pathLine);
                    if (profileChart) profileChart.destroy();
                    losResultContainer.innerHTML = '<p class="p-3 text-gray-500">Select a target from the list to analyze the path.</p>';
                    selectedRepeaterInfoDiv.innerHTML = '<p class="text-gray-500">Select a target to see its details here.</p>';
                }
                customMarkers.splice(index, 1);
                displayCustomMarkers();
            }
        }
        
        function clearLocalStorage() {
            if(confirm("Are you sure you want to delete all saved data? This cannot be undone.")) {
                localStorage.clear();
                window.location.reload();
            }
        }

        function getSetNameInput() {
            const desktopInput = document.getElementById('set-name-input-desktop');
            const mobileInput = document.getElementById('set-name-input-mobile');
            return window.innerWidth < 1024 ? mobileInput : desktopInput;
        }

        function getSetSelect() {
            const desktopSelect = document.getElementById('set-select-desktop');
            const mobileSelect = document.getElementById('set-select-mobile');
            return window.innerWidth < 1024 ? mobileSelect : desktopSelect;
        }

        function showSetErrorMessage(show) {
             document.getElementById('set-error-msg-desktop').classList.toggle('hidden', !show);
             document.getElementById('set-error-msg-mobile').classList.toggle('hidden', !show);
        }

        function saveCurrentSet() {
            const setNameInput = getSetNameInput();
            const setName = setNameInput.value.trim();
            if (!setName) {
                showSetErrorMessage(true);
                return;
            }
            showSetErrorMessage(false);

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            savedSets[setName] = {
                repeaterData: repeaterData,
                customMarkers: customMarkers
            };

            localStorage.setItem('repeaterSets', JSON.stringify(savedSets));
            localStorage.setItem('lastRepeaterSet', setName);
            updateSetSelector(Object.keys(savedSets), setName);
            setNameInput.value = '';
            filterStatusDiv.textContent = `Set "${setName}" saved.`;
            setTimeout(() => filterStatusDiv.textContent = '', 3000);
        }

        function deleteCurrentSet() {
            const setSelect = getSetSelect();
            const setName = setSelect.value;
            if (!setName) {
                filterStatusDiv.textContent = "No set selected to delete.";
                setTimeout(() => filterStatusDiv.textContent = '', 3000);
                return;
            }

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            delete savedSets[setName];
            localStorage.setItem('repeaterSets', JSON.stringify(savedSets));
            
            if (localStorage.getItem('lastRepeaterSet') === setName) {
                localStorage.removeItem('lastRepeaterSet');
            }
            
            window.location.reload();
        }

        function loadSelectedSet(event) {
            const setName = event.target.value;
            if (!setName) return;

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            if (savedSets[setName]) {
                localStorage.setItem('lastRepeaterSet', setName);
                window.location.reload();
            }
        }

        function loadFromLocalStorage() {
            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            const lastSetName = localStorage.getItem('lastRepeaterSet');
            
            updateSetSelector(Object.keys(savedSets), lastSetName);

            if (lastSetName && savedSets[lastSetName]) {
                repeaterData = savedSets[lastSetName].repeaterData || [];
                customMarkers = savedSets[lastSetName].customMarkers || [];

                filterStatusDiv.textContent = `Loaded set: ${lastSetName}`;
                updateFilteredView(repeaterData, getCurrentCoords());
            }
        }

        function updateSetSelector(setNames, currentSet) {
            ['desktop', 'mobile'].forEach(view => {
                const setSelect = document.getElementById(`set-select-${view}`);
                setSelect.innerHTML = '<option value="">Select a set...</option>';
                setNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    if (name === currentSet) {
                        option.selected = true;
                    }
                    setSelect.appendChild(option);
                });
            });
        }

        function handleDefaultRepeaterHeightChange(e) {
            const newDefaultHeight = parseFloat(e.target.value);
            if (isNaN(newDefaultHeight)) return;

            repeaterData.forEach(repeater => {
                if (repeater.antennaHeight === previousDefaultRepeaterHeight) {
                    repeater.antennaHeight = newDefaultHeight;
                }
            });
            
             customMarkers.forEach(marker => {
                if (marker.antennaHeight === previousDefaultRepeaterHeight) {
                    marker.antennaHeight = newDefaultHeight;
                }
            });

            updateFilteredView(repeaterData, getCurrentCoords());
            displayCustomMarkers();

            if (lastAnalyzedTarget) {
                const currentTargetData = repeaterData.find(r => r.id === lastAnalyzedTarget.id) || customMarkers.find(m => m.id === lastAnalyzedTarget.id);
                if(currentTargetData) {
                   analyzePath(currentTargetData, getCurrentCoords());
                }
            }
            
            previousDefaultRepeaterHeight = newDefaultHeight;
        }

    </script>
</body>
</html>

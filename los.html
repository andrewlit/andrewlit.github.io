<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio LOS & Path Loss Tool</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LeafletJS for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Leaflet MarkerCluster for avoiding marker overlap -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

    <!-- Chart.js for profile visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* Set a default font and ensure the map container has a defined height */
        body {
            font-family: 'Inter', sans-serif;
        }
        #map {
            height: 500px; /* Increased height for better view */
            border-radius: 0.5rem;
            z-index: 10;
        }
        /* Custom styles for Leaflet popups */
        .leaflet-popup-content-wrapper {
            border-radius: 0.5rem;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .crosshair-cursor {
            cursor: crosshair !important;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Radio LOS & Path Loss Tool</h1>
            <p class="text-lg text-gray-600 mt-2">Analyze repeater line-of-sight and estimate RF path loss.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: Controls and Repeater List -->
            <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Controls</h2>
                
                <div class="space-y-4">
                    <div>
                        <label for="location-search" class="block text-sm font-medium text-gray-700">Set Your Location</label>
                        <div class="mt-1 flex rounded-md shadow-sm">
                            <input type="text" id="location-search" placeholder="Address, city, or lat/lon..." class="flex-1 block w-full rounded-none rounded-l-md px-3 py-2 border border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            <button id="location-search-btn" class="inline-flex items-center px-3 rounded-r-md border border-l-0 border-gray-300 bg-gray-50 text-gray-500 hover:bg-gray-100">Search</button>
                        </div>
                        <p id="location-search-error" class="text-red-500 text-xs mt-1 hidden">Location not found.</p>
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="latitude" class="block text-sm font-medium text-gray-700">Your Latitude</label>
                            <input type="number" id="latitude" placeholder="e.g., 43.653" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="longitude" class="block text-sm font-medium text-gray-700">Your Longitude</label>
                            <input type="number" id="longitude" placeholder="e.g., -79.383" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                    </div>
                     <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="user-height" class="block text-sm font-medium text-gray-700">Your Height (m)</label>
                            <input type="number" id="user-height" value="10" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="repeater-height" class="block text-sm font-medium text-gray-700">Default Ht. (m)</label>
                            <input type="number" id="repeater-height" value="30" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                    </div>
                    <div>
                        <label for="environment-type" class="block text-sm font-medium text-gray-700">Clutter / Environment</label>
                        <select id="environment-type" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="rural">Rural/Open</option>
                            <option value="suburban">Suburban</option>
                            <option value="urban">Urban</option>
                        </select>
                    </div>
                    <div class="flex items-center">
                        <input id="curvature-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" checked>
                        <label for="curvature-checkbox" class="ml-2 text-sm font-medium text-gray-700">Earth Curvature</label>
                    </div>
                     <div class="flex items-center">
                        <input id="fresnel-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" checked>
                        <label for="fresnel-checkbox" class="ml-2 text-sm font-medium text-gray-700">Show Fresnel Zone</label>
                    </div>
                    <div class="flex items-center">
                        <input id="surface-model-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" checked>
                        <label for="surface-model-checkbox" class="ml-2 text-sm font-medium text-gray-700">Use Surface Model (Canada)</label>
                    </div>
                    <div class="flex space-x-2">
                         <button id="resetLocationBtn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300">Reset to My Location</button>
                         <button id="addMarkerBtn" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300">Place Custom Marker</button>
                    </div>
                    <div id="custom-marker-input-container" class="hidden space-y-2 mt-2 border-t pt-4">
                        <label for="custom-marker-name" class="block text-sm font-medium text-gray-700">Custom Marker Name (optional)</label>
                        <input type="text" id="custom-marker-name" placeholder="Enter name..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                        <label for="custom-marker-freq" class="block text-sm font-medium text-gray-700">Frequency (MHz)</label>
                        <input type="number" id="custom-marker-freq" value="146.520" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                     <div>
                        <label for="gpx-upload" class="block text-sm font-medium text-gray-700">Upload Repeaterbook GPX</label>
                        <input type="file" id="gpx-upload" accept=".gpx" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
                    </div>
                </div>
                
                <h2 class="text-2xl font-semibold mt-8 mb-4 border-b pb-2">Nearby Repeaters</h2>
                <div class="mb-4">
                    <input type="text" id="repeater-search" placeholder="Search callsign, freq, location..." class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <!-- Analysis Filter UI -->
                <div class="mb-4 p-4 bg-indigo-50 rounded-lg space-y-3">
                    <div id="filter-controls-grid" class="grid grid-cols-1 gap-4 items-end">
                        <div>
                            <label for="filter-mode-select" class="block text-sm font-medium text-gray-700">Filter Mode</label>
                            <select id="filter-mode-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option value="none">None</option>
                                <option value="pathLoss" selected>Path Loss</option>
                                <option value="los">Line of Sight</option>
                            </select>
                        </div>
                    </div>
                    <div id="path-loss-container" class="space-y-3">
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="tx-power" class="block text-sm font-medium text-gray-700">TX Power (W)</label>
                                <input type="number" id="tx-power" value="5" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                            </div>
                            <div>
                                <label for="tx-gain" class="block text-sm font-medium text-gray-700">TX Gain (dBi)</label>
                                <input type="number" id="tx-gain" value="2.15" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="rx-gain" class="block text-sm font-medium text-gray-700">RX Gain (dBi)</label>
                                <input type="number" id="rx-gain" value="2.15" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                            </div>
                            <div>
                                <label for="rx-threshold" class="block text-sm font-medium text-gray-700">RX Threshold (ÂµV)</label>
                                <input type="number" id="rx-threshold" value="0.5" min="0.5" step="0.1" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                            </div>
                        </div>
                         <div class="mt-2 text-sm text-center bg-indigo-100 p-2 rounded-md">
                            <p>Max Allowable Loss: <span id="calculated-path-loss-display" class="font-bold">...</span> dB</p>
                        </div>
                    </div>
                    <button id="run-batch-analysis" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 whitespace-nowrap">Analyze All Repeaters</button>
                </div>

                <div id="filter-status" class="text-sm text-gray-600 mb-2"></div>
                <div id="repeater-list" class="space-y-2 max-h-60 overflow-y-auto">
                    <p class="p-3 text-gray-500">Upload a GPX file or load a set to see repeater data.</p>
                </div>

                <h2 class="text-2xl font-semibold mt-4 mb-4 border-b pb-2">Custom Locations</h2>
                <div id="custom-list" class="space-y-2 max-h-40 overflow-y-auto">
                     <p class="p-3 text-gray-500">Click "Place Custom Marker" to add locations.</p>
                </div>

                <!-- Manage Sets for Desktop -->
                <div class="hidden lg:block mt-8 border-t pt-4">
                    <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Manage Sets</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="set-select-desktop" class="block text-sm font-medium text-gray-700">Load Set</label>
                            <select id="set-select-desktop" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                        </div>
                        <div>
                            <label for="set-name-input-desktop" class="block text-sm font-medium text-gray-700">New Set Name</label>
                            <input type="text" id="set-name-input-desktop" placeholder="Enter name to save..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                            <p id="set-error-msg-desktop" class="text-red-500 text-xs hidden mt-1">Please enter a name for the set.</p>
                        </div>
                        <div class="flex space-x-2">
                            <button id="saveSetBtn-desktop" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300">Save Current Set</button>
                            <button id="deleteSetBtn-desktop" class="w-full bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-700 transition duration-300">Delete Selected Set</button>
                        </div>
                         <div id="delete-confirmation-desktop" class="hidden space-y-2 mt-2 border-t pt-4">
                            <p class="text-sm text-center font-semibold">Are you sure? This is permanent.</p>
                             <div class="flex space-x-2">
                                 <button id="confirmDeleteBtn-desktop" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">Yes, Delete</button>
                                 <button id="cancelDeleteBtn-desktop" class="w-full bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400">Cancel</button>
                             </div>
                        </div>
                         <div>
                            <button id="clearDataBtn-desktop" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 mt-4">Clear All Saved Data</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Map and Results -->
            <div class="lg:col-span-2 bg-white p-6 rounded-lg shadow-lg">
                <div id="map" class="mb-6 border border-gray-200"></div>
                
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Selected Target Details</h2>
                <div id="selected-repeater-info" class="p-4 rounded-lg bg-gray-50">
                    <p class="text-gray-500">Select a target to see its details here.</p>
                </div>

                <h2 class="text-2xl font-semibold mt-6 mb-4 border-b pb-2">Line-of-Sight Analysis</h2>
                <div id="los-result-container" class="text-center p-4 rounded-lg bg-gray-50">
                     <p class="text-gray-500">Select a target from the list to analyze the path.</p>
                </div>
                
                <h2 class="text-2xl font-semibold mt-6 mb-4 border-b pb-2">RF Path Loss</h2>
                <div id="path-loss-result-container" class="text-center p-4 rounded-lg bg-gray-50">
                    <p class="text-gray-500">Path loss is calculated for clear line-of-sight paths.</p>
                </div>
                
                <div class="mt-6 h-96">
                    <canvas id="profileChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Manage Sets for Mobile -->
        <div class="lg:hidden mt-8 bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Manage Sets</h2>
            <div class="space-y-4">
                <div>
                    <label for="set-select-mobile" class="block text-sm font-medium text-gray-700">Load Set</label>
                    <select id="set-select-mobile" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                </div>
                <div>
                    <label for="set-name-input-mobile" class="block text-sm font-medium text-gray-700">New Set Name</label>
                    <input type="text" id="set-name-input-mobile" placeholder="Enter name to save..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    <p id="set-error-msg-mobile" class="text-red-500 text-xs hidden mt-1">Please enter a name for the set.</p>
                </div>
                <div class="flex space-x-2">
                    <button id="saveSetBtn-mobile" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300">Save Current Set</button>
                    <button id="deleteSetBtn-mobile" class="w-full bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-700 transition duration-300">Delete Selected Set</button>
                </div>
                 <div id="delete-confirmation-mobile" class="hidden space-y-2 mt-2 border-t pt-4">
                    <p class="text-sm text-center font-semibold">Are you sure? This is permanent.</p>
                     <div class="flex space-x-2">
                         <button id="confirmDeleteBtn-mobile" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">Yes, Delete</button>
                         <button id="cancelDeleteBtn-mobile" class="w-full bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400">Cancel</button>
                     </div>
                </div>
                 <div>
                    <button id="clearDataBtn-mobile" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 mt-4">Clear All Saved Data</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        let repeaterData = [];
        let customMarkers = [];
        let isPlacingMarker = false;
        let lastAnalyzedTarget = null;
        let placementInfo = { mode: null, id: null }; 
        let previousDefaultRepeaterHeight = 30;
        let analysisController = null;
        const DEFAULT_LAT = 43.6532;
        const DEFAULT_LON = -79.3832;
        
        // --- Physical Constants ---
        const K_FACTOR = 4 / 3; // Standard k-factor for effective Earth radius calculation
        const EARTH_RADIUS_METERS = 6378137.0; 
        const EFFECTIVE_EARTH_RADIUS = EARTH_RADIUS_METERS * K_FACTOR;
        
        // --- DOM Element References ---
        let latInput, lonInput, userHeightInput, repeaterHeightInput, gpxUpload,
            addMarkerBtn, resetLocationBtn, customMarkerInputContainer, customMarkerNameInput,
            customMarkerFreqInput, filterStatusDiv, repeaterListDiv, customListDiv,
            losResultContainer, selectedRepeaterInfoDiv, pathLossResultContainer,
            profileChartCanvas, repeaterSearchInput, curvatureCheckbox, surfaceModelCheckbox,
            fresnelCheckbox, runBatchAnalysisBtn, filterModeSelect, pathLossContainer,
            txPowerInput, txGainInput, rxGainInput, rxThresholdInput, environmentTypeSelect,
            diffractionModelSelect, locationSearchInput, locationSearchBtn, locationSearchError;

        // --- Map and Chart Initialization ---
        let map;
        let userMarker, repeaterMarker, pathLine;
        let profileChart;
        let markerClusterGroup;
        let customMarkerLayer;
        const TILE_URL = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        const TILE_ATTRIBUTION = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';

        // --- Marker Icons ---
        let greenIcon, yellowIcon, redIcon, greyIcon, blueIcon;

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            latInput = document.getElementById('latitude');
            lonInput = document.getElementById('longitude');
            userHeightInput = document.getElementById('user-height');
            repeaterHeightInput = document.getElementById('repeater-height');
            gpxUpload = document.getElementById('gpx-upload');
            addMarkerBtn = document.getElementById('addMarkerBtn');
            resetLocationBtn = document.getElementById('resetLocationBtn');
            customMarkerInputContainer = document.getElementById('custom-marker-input-container');
            customMarkerNameInput = document.getElementById('custom-marker-name');
            customMarkerFreqInput = document.getElementById('custom-marker-freq');
            filterStatusDiv = document.getElementById('filter-status');
            repeaterListDiv = document.getElementById('repeater-list');
            customListDiv = document.getElementById('custom-list');
            losResultContainer = document.getElementById('los-result-container');
            pathLossResultContainer = document.getElementById('path-loss-result-container');
            selectedRepeaterInfoDiv = document.getElementById('selected-repeater-info');
            profileChartCanvas = document.getElementById('profileChart');
            repeaterSearchInput = document.getElementById('repeater-search');
            curvatureCheckbox = document.getElementById('curvature-checkbox');
            surfaceModelCheckbox = document.getElementById('surface-model-checkbox');
            fresnelCheckbox = document.getElementById('fresnel-checkbox');
            runBatchAnalysisBtn = document.getElementById('run-batch-analysis');
            filterModeSelect = document.getElementById('filter-mode-select');
            pathLossContainer = document.getElementById('path-loss-container');
            txPowerInput = document.getElementById('tx-power');
            txGainInput = document.getElementById('tx-gain');
            rxGainInput = document.getElementById('rx-gain');
            rxThresholdInput = document.getElementById('rx-threshold');
            environmentTypeSelect = document.getElementById('environment-type');
            locationSearchInput = document.getElementById('location-search');
            locationSearchBtn = document.getElementById('location-search-btn');
            locationSearchError = document.getElementById('location-search-error');
            
            map = L.map('map').setView([DEFAULT_LAT, DEFAULT_LON], 9);
            L.tileLayer(TILE_URL, { attribution: TILE_ATTRIBUTION }).addTo(map);
            markerClusterGroup = L.markerClusterGroup({ maxClusterRadius: 20 });
            map.addLayer(markerClusterGroup);
            customMarkerLayer = L.layerGroup().addTo(map);

            initializeIcons();
            setLocation(DEFAULT_LAT, DEFAULT_LON);
            requestUserGeolocation();
            loadFromLocalStorage();

            map.on('click', onMapClick);
            gpxUpload.addEventListener('change', handleFileUpload);
            addMarkerBtn.addEventListener('click', () => togglePlaceMarkerMode('custom'));
            resetLocationBtn.addEventListener('click', requestUserGeolocation);
            runBatchAnalysisBtn.addEventListener('click', runBatchAnalysis);
            filterModeSelect.addEventListener('change', handleFilterModeChange);
            locationSearchBtn.addEventListener('click', handleLocationSearch);
            locationSearchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleLocationSearch();
                }
            });

            const reanalyzeInputs = [userHeightInput, curvatureCheckbox, surfaceModelCheckbox, environmentTypeSelect, fresnelCheckbox];
            reanalyzeInputs.forEach(input => {
                input.addEventListener('input', () => { 
                    if (lastAnalyzedTarget) analyzePath(lastAnalyzedTarget, getCurrentCoords()); 
                });
            });
            
            const liveFilterInputs = [repeaterSearchInput, txPowerInput, txGainInput, rxGainInput, rxThresholdInput];
            liveFilterInputs.forEach(input => {
                input.addEventListener('input', () => {
                    updatePathLossDisplay();
                    updateFilteredView(repeaterData, getCurrentCoords());
                });
            });
            
            repeaterHeightInput.addEventListener('focus', (e) => {
                previousDefaultRepeaterHeight = parseFloat(e.target.value) || 30;
            });
            repeaterHeightInput.addEventListener('input', handleDefaultRepeaterHeightChange);
            
            ['desktop', 'mobile'].forEach(view => {
                document.getElementById(`saveSetBtn-${view}`).addEventListener('click', saveCurrentSet);
                document.getElementById(`deleteSetBtn-${view}`).addEventListener('click', () => {
                    document.getElementById(`delete-confirmation-${view}`).classList.remove('hidden');
                });
                document.getElementById(`confirmDeleteBtn-${view}`).addEventListener('click', deleteCurrentSet);
                document.getElementById(`cancelDeleteBtn-${view}`).addEventListener('click', () => {
                     document.getElementById(`delete-confirmation-${view}`).classList.add('hidden');
                });
                document.getElementById(`set-select-${view}`).addEventListener('change', loadSelectedSet);
                document.getElementById(`clearDataBtn-${view}`).addEventListener('click', clearLocalStorage);
            });

            handleFilterModeChange();
            updatePathLossDisplay();
        });


        // --- Core Functions ---
        
        function initializeIcons() {
            const iconOptions = {
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
            };
            greenIcon = L.icon({ ...iconOptions, iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png' });
            yellowIcon = L.icon({ ...iconOptions, iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png' });
            redIcon = L.icon({ ...iconOptions, iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png' });
            greyIcon = L.icon({ ...iconOptions, iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png' });
            blueIcon = L.icon({ ...iconOptions, iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png' });
        }

        async function handleLocationSearch() {
            const query = locationSearchInput.value.trim();
            if (!query) return;

            locationSearchBtn.innerHTML = '<div class="loading-spinner !w-4 !h-4"></div>';
            locationSearchError.classList.add('hidden');

            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=1`);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                if (data && data.length > 0) {
                    const { lat, lon } = data[0];
                    setLocation(parseFloat(lat), parseFloat(lon));
                    if (lastAnalyzedTarget) {
                        analyzePath(lastAnalyzedTarget, { lat: parseFloat(lat), lon: parseFloat(lon) });
                    }
                } else {
                    locationSearchError.classList.remove('hidden');
                }
            } catch (error) {
                console.error("Geocoding error:", error);
                locationSearchError.classList.remove('hidden');
            } finally {
                locationSearchBtn.textContent = 'Search';
            }
        }

        function handleFilterModeChange() {
            const filterMode = filterModeSelect.value;
            const isPathLossMode = filterMode === 'pathLoss';
            pathLossContainer.classList.toggle('hidden', !isPathLossMode);
            updateFilteredView(repeaterData, getCurrentCoords());
        }

        function updatePathLossDisplay() {
            const displayElement = document.getElementById('calculated-path-loss-display');
            if (filterModeSelect.value === 'pathLoss') {
                const maxLoss = calculateMaxPathLoss();
                displayElement.textContent = maxLoss.toFixed(1);
            }
        }

        function requestUserGeolocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    setLocation(position.coords.latitude, position.coords.longitude);
                }, () => {
                    console.warn('Could not retrieve user location. Using default.');
                });
            }
        }

        function setLocation(lat, lon) {
            latInput.value = lat.toFixed(5);
            lonInput.value = lon.toFixed(5);
            updateUserMarker(lat, lon);
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            repeaterListDiv.innerHTML = `<div class="p-3"><div class="flex items-center"><div class="loading-spinner !w-4 !h-4 mr-2"></div><span>Parsing GPX...</span></div></div>`;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    repeaterData = parseGPX(e.target.result);
                    repeaterData.forEach(r => {
                        delete r.pathLoss;
                        delete r.isVisible;
                    });
                    filterStatusDiv.textContent = `Loaded ${repeaterData.length} repeaters. Click "Analyze All Repeaters" to begin.`;
                    updateFilteredView(repeaterData, getCurrentCoords());
                } catch (error) {
                    filterStatusDiv.textContent = `Error parsing GPX: ${error.message}`;
                    repeaterListDiv.innerHTML = '<p class="p-3 text-red-500">Failed to parse GPX file. Please check format.</p>';
                }
            };
            reader.readAsText(file);
        }

        function parseGPX(gpxString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxString, "text/xml");
            const waypoints = xmlDoc.getElementsByTagName("wpt");
            const data = [];
            const defaultHeight = parseFloat(repeaterHeightInput.value) || 30;

            for (let i = 0; i < waypoints.length; i++) {
                const wpt = waypoints[i];
                const nameNode = wpt.getElementsByTagName("name")[0];
                const cmtNode = wpt.getElementsByTagName("cmt")[0];
                
                if (!nameNode || !cmtNode) continue;
                
                const nameStr = nameNode.textContent;
                const parts = nameStr.split(/\s+/);

                let callsign = parts[0] || 'N/A';
                let outputFreqStr = 'N/A';
                let offsetSign = 'N/A';
                let uplinkTone = 'N/A';

                const infoParts = parts.slice(1);
                let freqIndex = -1;

                for (let j = 0; j < infoParts.length; j++) {
                    const part = infoParts[j];
                    const num = parseFloat(part);
                    if (!isNaN(num) && num > 20) {
                        outputFreqStr = part.replace(/[+-]$/, '');
                        if (part.endsWith('+') || part.endsWith('-')) {
                            offsetSign = part.slice(-1);
                        }
                        freqIndex = j;
                        break;
                    }
                }

                if (freqIndex !== -1) {
                    infoParts.splice(freqIndex, 1);
                }

                for (const part of infoParts) {
                    if (part === '+' || part === '-') {
                        offsetSign = part;
                    } else {
                        uplinkTone = part;
                    }
                }

                const outputFreq = parseFloat(outputFreqStr);
                let inputFreq = 'N/A';

                if (!isNaN(outputFreq) && (offsetSign === '+' || offsetSign === '-')) {
                    let standardOffset = 0.6;
                    if (outputFreq >= 440 && outputFreq <= 450) {
                        standardOffset = 5.0;
                    } else if (outputFreq >= 222 && outputFreq <= 225) {
                        standardOffset = 1.6;
                    }

                    if (offsetSign === '+') {
                        inputFreq = (outputFreq + standardOffset).toFixed(4);
                    } else {
                        inputFreq = (outputFreq - standardOffset).toFixed(4);
                    }
                }

                data.push({
                    id: `repeater-${i}`,
                    lat: parseFloat(wpt.getAttribute("lat")),
                    lon: parseFloat(wpt.getAttribute("lon")),
                    callsign: callsign,
                    outputFreq: outputFreqStr,
                    inputFreq: inputFreq,
                    offset: offsetSign,
                    uplinkTone: uplinkTone,
                    antennaHeight: defaultHeight,
                    location: cmtNode.textContent.replace(callsign, '').replace('OPEN', '').trim()
                });
            }
            return data;
        }
        
        const delay = ms => new Promise(res => setTimeout(res, ms));

        async function runBatchAnalysis() {
            if (analysisController) {
                analysisController.abort();
            }
            analysisController = new AbortController();
            const signal = analysisController.signal;

            if (repeaterData.length === 0) {
                filterStatusDiv.textContent = "Please upload a repeater GPX file first.";
                setTimeout(() => filterStatusDiv.textContent = '', 3000);
                return;
            }

            const userCoords = getCurrentCoords();
            let completedCount = 0;
            const repeatersToAnalyze = repeaterData.filter(r => !r.locationUnknown);
            const totalRepeaters = repeatersToAnalyze.length;
            
            const startTime = Date.now();
            
            repeaterData.forEach(r => {
                delete r.pathLoss;
                delete r.isVisible;
            });
            updateFilteredView(repeaterData, userCoords);

            const concurrencyLimit = 5;
            const queue = [...repeatersToAnalyze];
            
            const worker = async () => {
                while(queue.length > 0) {
                    if (signal.aborted) return;
                    const repeater = queue.shift();
                    if (!repeater) continue;

                    const result = await getPathAnalysisForRepeater(repeater, userCoords);
                    if (signal.aborted) return;

                    repeater.pathLoss = result.pathLoss;
                    repeater.isVisible = result.isVisible;
                    completedCount++;
                    
                    updateFilteredView(repeaterData, userCoords);
                    
                    const elapsedTime = Date.now() - startTime;
                    const avgTime = elapsedTime / completedCount;
                    const remainingTime = avgTime * (totalRepeaters - completedCount);
                    const formattedTime = formatRemainingTime(remainingTime);
                    const reachableCount = getFilteredData(repeaterData).length;
                    
                    filterStatusDiv.innerHTML = `<div class="flex items-center"><div class="loading-spinner !w-4 !h-4 mr-2"></div><span>Analyzed ${completedCount} of ${totalRepeaters}... Found ${reachableCount} reachable. (Est. ${formattedTime} left)</span></div>`;
                }
            };

            const workers = Array(concurrencyLimit).fill(null).map(worker);
            
            try {
                await Promise.all(workers);
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Batch analysis was cancelled.');
                    filterStatusDiv.textContent = 'Analysis cancelled.';
                    repeaterData.forEach(r => {
                        delete r.pathLoss;
                        delete r.isVisible;
                    });
                    updateFilteredView(repeaterData, userCoords);
                    return;
                }
                throw error;
            }

            if (signal.aborted) return;

            const reachableCount = getFilteredData(repeaterData).length;
            filterStatusDiv.textContent = `Analysis complete. Found ${reachableCount} of ${totalRepeaters} repeaters matching criteria.`;
            updateFilteredView(repeaterData, userCoords);
        }

        async function getPathAnalysisForRepeater(repeater, userCoords) {
            try {
                const initialPoints = getPointsOnPath(userCoords, { lat: repeater.lat, lon: repeater.lon }, 100);
                let elevationProfile = await getElevationProfile(initialPoints);
                const userAntennaHeight = parseFloat(userHeightInput.value) || 10;
                const repeaterAntennaHeight = parseFloat(repeater.antennaHeight) || parseFloat(repeaterHeightInput.value) || 30;
                const frequencyMHz = parseFloat(repeater.outputFreq || repeater.frequency) || 146.520;
                
                let { isVisible } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);

                const closeApproachSegments = findCloseApproachSegments(elevationProfile, userAntennaHeight, repeaterAntennaHeight, 10, frequencyMHz);
                if (closeApproachSegments.length > 0) {
                    elevationProfile = await refineElevationProfile(elevationProfile, initialPoints, closeApproachSegments);
                    ({ isVisible } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz));
                }

                const distanceKm = getDistance(userCoords, repeater);
                const fspl = calculateFreeSpacePathLoss(distanceKm, frequencyMHz);
                let totalPathLoss = fspl;

                if (!isVisible) {
                    const deygoutResult = calculateDeygoutDiffractionLoss(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);
                    const bullingtonResult = calculateBullingtonDiffractionLoss(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);
                    const diffractionLoss = Math.max(deygoutResult.totalLoss, bullingtonResult.loss);
                    totalPathLoss += diffractionLoss;
                }
                
                totalPathLoss += getClutterLoss(frequencyMHz);
                
                return { pathLoss: totalPathLoss, isVisible: isVisible };
            } catch (error) {
                console.error(`Failed to analyze path loss for ${repeater.callsign}:`, error);
                return { pathLoss: Infinity, isVisible: false };
            }
        }

        function formatRemainingTime(ms) {
            if (ms < 1000) return "< 1s";
            let totalSeconds = Math.round(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            }
            return `${seconds}s`;
        }

        function calculateMaxPathLoss() {
            const txPowerWatts = parseFloat(txPowerInput.value) || 0;
            const txGain = parseFloat(txGainInput.value) || 0;
            const rxGain = parseFloat(rxGainInput.value) || 0;
            const rxThresholdMicrovolts = parseFloat(rxThresholdInput.value) || 0.5;

            if (txPowerWatts <= 0 || rxThresholdMicrovolts <= 0) return 0;

            const power_dBm = 10 * Math.log10(txPowerWatts * 1000);
            const threshold_volts = rxThresholdMicrovolts / 1e6;
            const threshold_dBm = 10 * Math.log10( (Math.pow(threshold_volts, 2) / 50) * 1000 );
            
            return power_dBm + txGain + rxGain - threshold_dBm;
        }
        
        function getFilteredData(allRepeaters) {
            const searchTerm = repeaterSearchInput.value.toLowerCase();
            const filterMode = filterModeSelect.value;
            
            let filtered = [...allRepeaters];

            if (searchTerm) {
                filtered = filtered.filter(r => 
                    r.callsign.toLowerCase().includes(searchTerm) ||
                    (r.outputFreq && r.outputFreq.includes(searchTerm)) ||
                    (r.inputFreq && r.inputFreq.includes(searchTerm)) ||
                    r.location.toLowerCase().includes(searchTerm)
                );
            }
            
            const analysisHasRun = allRepeaters.some(r => r.pathLoss !== undefined || r.isVisible !== undefined);

            if (filterMode !== 'none' && analysisHasRun) {
                if (filterMode === 'pathLoss') {
                    const maxPathLoss = calculateMaxPathLoss();
                    filtered = filtered.filter(r => typeof r.pathLoss === 'number' && r.pathLoss <= maxPathLoss);
                } else if (filterMode === 'los') {
                    filtered = filtered.filter(r => r.isVisible);
                }
            }

            return filtered;
        }

        function updateFilteredView(allRepeaters, userCoords) {
            const filteredData = getFilteredData(allRepeaters);
            const filterMode = filterModeSelect.value;
            const analysisHasRun = allRepeaters.some(r => r.pathLoss !== undefined || r.isVisible !== undefined);

            const maxLossThreshold = calculateMaxPathLoss();
            const greenThreshold = maxLossThreshold - 10;

            filteredData.sort((a, b) => {
                if (filterMode === 'pathLoss' && analysisHasRun) {
                    const pa = (typeof a.pathLoss === 'number') ? a.pathLoss : Infinity;
                    const pb = (typeof b.pathLoss === 'number') ? b.pathLoss : Infinity;
                    return pa - pb;
                }
                return getDistance(userCoords, a) - getDistance(userCoords, b);
            });

            repeaterListDiv.innerHTML = '';
            markerClusterGroup.clearLayers();

            if (filteredData.length === 0) {
                 repeaterListDiv.innerHTML = '<p class="p-3 text-gray-500">No repeaters match the current filters.</p>';
            }

            filteredData.forEach(repeater => {
                const distance = getDistance(userCoords, repeater).toFixed(1);
                
                let pathLossHTML = '';
                let markerColor = 'grey';

                if (typeof repeater.pathLoss === 'number') {
                    if (repeater.pathLoss <= greenThreshold) {
                        pathLossHTML = `<p class="text-sm font-medium text-green-600">Loss: ${repeater.pathLoss.toFixed(1)} dB</p>`;
                        markerColor = 'green';
                    } else if (repeater.pathLoss <= maxLossThreshold) {
                        pathLossHTML = `<p class="text-sm font-medium text-yellow-600">Loss: ${repeater.pathLoss.toFixed(1)} dB</p>`;
                        markerColor = 'yellow';
                    } else {
                        pathLossHTML = `<p class="text-sm font-medium text-red-500">Loss: ${repeater.pathLoss.toFixed(1)} dB</p>`;
                        markerColor = 'red';
                    }
                } else if (repeater.isVisible === true) {
                    pathLossHTML = `<p class="text-sm font-medium text-green-600">Clear LOS</p>`;
                    markerColor = 'green';
                } else if (repeater.isVisible === false) {
                    pathLossHTML = `<p class="text-sm font-medium text-red-500">Obstructed</p>`;
                    markerColor = 'red';
                }

                const item = document.createElement('div');
                item.className = 'p-3 border rounded-lg hover:bg-gray-100';
                item.innerHTML = `
                    <div class="flex justify-between items-start cursor-pointer" data-repeater-id="${repeater.id}">
                        <div>
                            <p class="font-bold">${repeater.callsign}</p>
                            <p class="text-sm text-gray-600">${repeater.location}</p>
                        </div>
                        <div class="text-right">
                            <p class="text-sm font-medium text-gray-800">${distance} km</p>
                            ${pathLossHTML}
                        </div>
                    </div>
                    <div class="mt-2 text-xs text-gray-700 grid grid-cols-2 gap-x-4 gap-y-1">
                        <span><span class="font-semibold">Output:</span> ${repeater.outputFreq} (${repeater.offset})</span>
                        <span><span class="font-semibold">Input:</span> ${repeater.inputFreq}</span>
                        ${repeater.uplinkTone !== 'N/A' ? `<span><span class="font-semibold">Tone:</span> ${repeater.uplinkTone}</span>` : ''}
                        <div class="col-span-2 mt-1">
                            <label for="height-${repeater.id}" class="text-xs font-medium">Antenna Ht (m):</label>
                            <input type="number" id="height-${repeater.id}" value="${repeater.antennaHeight}" class="w-20 ml-1 px-1 py-0.5 text-xs border border-gray-300 rounded">
                        </div>
                    </div>
                `;
                item.querySelector(`[data-repeater-id="${repeater.id}"]`).onclick = () => analyzePath(repeater, getCurrentCoords());
                
                const heightInput = item.querySelector(`#height-${repeater.id}`);
                heightInput.addEventListener('input', (e) => {
                    const newHeight = parseFloat(e.target.value);
                    const targetRepeater = repeaterData.find(r => r.id === repeater.id);
                    if (targetRepeater && !isNaN(newHeight)) {
                        targetRepeater.antennaHeight = newHeight;
                        if (lastAnalyzedTarget && lastAnalyzedTarget.id === repeater.id) {
                            analyzePath(targetRepeater, getCurrentCoords());
                        }
                    }
                });

                repeaterListDiv.appendChild(item);
                addRepeaterMarkerToMap(repeater, markerColor);
            });
        }
        
        function addRepeaterMarkerToMap(repeater, color) {
            let icon;
            switch(color) {
                case 'green': icon = greenIcon; break;
                case 'yellow': icon = yellowIcon; break;
                case 'red': icon = redIcon; break;
                default: icon = greyIcon;
            }

            const marker = L.marker([repeater.lat, repeater.lon], { icon: icon, draggable: true })
                .bindPopup(`<b>${repeater.callsign}</b><br>${repeater.location}<br>${repeater.outputFreq} MHz<br><button class="mt-2 p-1 bg-indigo-500 text-white rounded text-xs" onclick='analyzePathFromPopup(${JSON.stringify(repeater)})'>Check Path</button>`);
            
            marker.on('dragend', (event) => {
                const newCoords = event.target.getLatLng();
                const targetRepeater = repeaterData.find(r => r.id === repeater.id);
                if (targetRepeater) {
                    targetRepeater.lat = newCoords.lat;
                    targetRepeater.lon = newCoords.lng;
                    targetRepeater.location = `Custom Position (${newCoords.lat.toFixed(3)}, ${newCoords.lng.toFixed(3)})`;
                }
                repeaterData.forEach(r => {
                    delete r.pathLoss;
                    delete r.isVisible;
                });
                updateFilteredView(repeaterData, getCurrentCoords());
                if (lastAnalyzedTarget && lastAnalyzedTarget.id === repeater.id) {
                    analyzePath(repeater, getCurrentCoords());
                }
            });

            markerClusterGroup.addLayer(marker);
        }

        function analyzePathFromPopup(repeater) {
            const fullRepeaterData = repeaterData.find(r => r.id === repeater.id);
            if(fullRepeaterData) {
                analyzePath(fullRepeaterData, getCurrentCoords());
            }
            map.closePopup();
        }

        function updateUserMarker(lat, lon) {
            if (userMarker) {
                map.removeLayer(userMarker);
            }
            userMarker = L.marker([lat, lon], {
                draggable: true,
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                })
            }).addTo(map);

            userMarker.bindPopup('Your Location').openPopup();
            map.setView([lat, lon], 9);

            userMarker.on('dragend', function(event) {
                if (analysisController) {
                    analysisController.abort();
                }
                const newCoords = event.target.getLatLng();
                const standardizedCoords = { lat: newCoords.lat, lon: newCoords.lng };
                latInput.value = standardizedCoords.lat.toFixed(5);
                lonInput.value = standardizedCoords.lon.toFixed(5);
                
                repeaterData.forEach(r => {
                    delete r.pathLoss;
                    delete r.isVisible;
                });
                filterStatusDiv.textContent = "Location changed. Please re-run analysis.";
                
                updateFilteredView(repeaterData, standardizedCoords);
                displayCustomMarkers();
                if (lastAnalyzedTarget) {
                    analyzePath(lastAnalyzedTarget, standardizedCoords);
                }
            });
        }
        
        function getCurrentCoords() {
            return {
                lat: parseFloat(latInput.value),
                lon: parseFloat(lonInput.value)
            };
        }

        async function analyzePath(target, userCoords) {
            lastAnalyzedTarget = target;
            displaySelectedRepeaterInfo(target);
            losResultContainer.innerHTML = '<div class="flex justify-center items-center"><div class="loading-spinner"></div><p class="ml-4">Analyzing terrain...</p></div>';
            pathLossResultContainer.innerHTML = '<p class="text-gray-500">Awaiting line-of-sight result...</p>';
            if (profileChart) profileChart.destroy();

            if (repeaterMarker) map.removeLayer(repeaterMarker);
            repeaterMarker = L.marker([target.lat, target.lon], {
                 icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                })
            }).addTo(map);
            repeaterMarker.options.customId = target.id;
            repeaterMarker.bindPopup(`<b>${target.callsign || target.name}</b>`).openPopup();

            const initialPoints = getPointsOnPath(userCoords, { lat: target.lat, lon: target.lon }, 150);
            
            try {
                let elevationProfile = await getElevationProfile(initialPoints);
                const userAntennaHeight = parseFloat(userHeightInput.value) || 10;
                let repeaterAntennaHeight = parseFloat(target.antennaHeight) || parseFloat(repeaterHeightInput.value) || 30;
                const frequencyMHz = parseFloat(target.outputFreq || target.frequency) || 146.520;
                
                let { isVisible, obstructionPoint } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);
                let allObstructions = [obstructionPoint].filter(Boolean);
                let bullingtonResult = null;

                const closeApproachSegments = findCloseApproachSegments(elevationProfile, userAntennaHeight, repeaterAntennaHeight, 10, frequencyMHz);
                if (closeApproachSegments.length > 0 && elevationProfile.length < 500) { // Limit refinement to avoid excessive calls
                    losResultContainer.innerHTML = '<div class="flex justify-center items-center"><div class="loading-spinner"></div><p class="ml-4">Refining path analysis...</p></div>';
                    elevationProfile = await refineElevationProfile(elevationProfile, initialPoints, closeApproachSegments);
                    ({ isVisible, obstructionPoint } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz));
                    allObstructions = [obstructionPoint].filter(Boolean);
                }

                displayLosResult(isVisible, obstructionPoint, userCoords, target, elevationProfile.length);
                
                const distanceKm = getDistance(userCoords, target);
                const fspl = calculateFreeSpacePathLoss(distanceKm, frequencyMHz);
                let totalPathLoss = fspl;
                let pathLossBreakdown = { fspl: fspl, model: 'Free-Space Path Loss' };

                if (!isVisible) {
                    const deygoutResult = calculateDeygoutDiffractionLoss(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);
                    bullingtonResult = calculateBullingtonDiffractionLoss(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);

                    let diffractionLoss = 0;
                    if (bullingtonResult.loss > deygoutResult.totalLoss) {
                        diffractionLoss = bullingtonResult.loss;
                        pathLossBreakdown.model = "Bullington (Worst Case)";
                        allObstructions = []; // Clear Deygout obstructions if Bullington is used
                    } else {
                        diffractionLoss = deygoutResult.totalLoss;
                        allObstructions = deygoutResult.obstructions;
                        pathLossBreakdown.model = "Deygout '94 (Worst Case)";
                        bullingtonResult = null; // Nullify Bullington result so it doesn't draw
                    }
                    totalPathLoss += diffractionLoss;
                    pathLossBreakdown.diffraction = diffractionLoss;
                }

                const clutterLoss = getClutterLoss(frequencyMHz);
                totalPathLoss += clutterLoss;
                pathLossBreakdown.clutter = clutterLoss;

                displayPathLossResult(totalPathLoss, isVisible, target, pathLossBreakdown);

                drawProfileChart(elevationProfile, userAntennaHeight, repeaterAntennaHeight, isVisible, allObstructions, frequencyMHz, bullingtonResult);
                drawPathOnMap(initialPoints, isVisible);

            } catch (error) {
                console.error("Error during analysis:", error);
                losResultContainer.innerHTML = `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                    <strong class="font-bold">Error!</strong>
                    <span class="block sm:inline">Could not fetch elevation data. ${error.message}</span>
                </div>`;
            }
        }

        function getPointsOnPath(start, end, numPoints = 100) {
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const t = i / (numPoints - 1);
                points.push({
                    lat: start.lat + t * (end.lat - start.lat),
                    lon: start.lon + t * (end.lon - start.lon)
                });
            }
            return points;
        }

        async function getElevationProfile(points) {
            if (points.length < 2) return [];

            const isCanadian = (point) => point.lat > 41.5 && point.lon < -60 && point.lon > -141;

            const segments = [];
            let currentSegment = { type: isCanadian(points[0]) ? 'can' : 'world', points: [] };

            for (const point of points) {
                const pointType = isCanadian(point) ? 'can' : 'world';
                if (pointType !== currentSegment.type && currentSegment.points.length > 0) {
                    segments.push(currentSegment);
                    currentSegment = { type: pointType, points: [] };
                }
                currentSegment.points.push(point);
            }
            if (currentSegment.points.length > 0) {
                segments.push(currentSegment);
            }

            const promises = segments.map(async (segment) => {
                if (segment.points.length < 2) {
                    segment.type = 'world';
                }

                let apiPoints = segment.points;
                if (segment.type === 'can' && apiPoints.length < 2) {
                    const prevPoint = points[points.indexOf(apiPoints[0]) - 1] || apiPoints[0];
                    apiPoints = [prevPoint, ...apiPoints];
                }

                let apiUrl;
                let isCanRequest = false;

                if (segment.type === 'can') {
                    isCanRequest = true;
                    const model = surfaceModelCheckbox.checked ? 'cdsm' : 'cdem';
                    const start = apiPoints[0];
                    const end = apiPoints[apiPoints.length - 1];
                    const path = `LINESTRING(${start.lon} ${start.lat}, ${end.lon} ${end.lat})`;
                    apiUrl = `https://geogratis.gc.ca/services/elevation/${model}/profile?path=${encodeURIComponent(path)}&steps=${apiPoints.length > 1 ? apiPoints.length - 2 : 0}`;
                } else { 
                    const latitudes = apiPoints.map(p => p.lat.toFixed(5)).join(',');
                    const longitudes = apiPoints.map(p => p.lon.toFixed(5)).join(',');
                    apiUrl = `https://api.open-meteo.com/v1/elevation?latitude=${latitudes}&longitude=${longitudes}`;
                }

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) throw new Error(`API request failed for a segment: ${response.status}`);
                    const data = await response.json();

                    if (isCanRequest) {
                        if (!data || !Array.isArray(data)) throw new Error('Invalid data from NRCan API.');
                        const hasZeroDrop = data.some((p, i) => i > 0 && p.altitude === 0 && data[i-1].altitude !== 0);
                        if(hasZeroDrop) {
                            console.warn("Canadian API returned zero data, falling back to global API for this segment.");
                            throw new Error("Zero drop detected in Canadian data");
                        }
                        return data.map(p => ({
                            elevation: p.altitude,
                            location: { lat: p.geometry.coordinates[1], lon: p.geometry.coordinates[0] }
                        }));
                    } else { 
                        if (!data.elevation) throw new Error('Invalid data from Open-Meteo API.');
                        return data.elevation.map((elevation, index) => ({
                            elevation: elevation,
                            location: { lat: apiPoints[index].lat, lon: apiPoints[index].lon }
                        }));
                    }
                } catch (error) {
                    if (isCanRequest) {
                        console.warn(`Falling back to global API for a Canadian segment due to error: ${error.message}`);
                        const latitudes = apiPoints.map(p => p.lat.toFixed(5)).join(',');
                        const longitudes = apiPoints.map(p => p.lon.toFixed(5)).join(',');
                        const fallbackUrl = `https://api.open-meteo.com/v1/elevation?latitude=${latitudes}&longitude=${longitudes}`;
                        const fallbackResponse = await fetch(fallbackUrl);
                        if (!fallbackResponse.ok) throw new Error('Fallback API request also failed.');
                        const fallbackData = await fallbackResponse.json();
                        if (!fallbackData.elevation) throw new Error('Invalid data from fallback API.');
                        return fallbackData.elevation.map((elevation, index) => ({
                            elevation: elevation,
                            location: { lat: apiPoints[index].lat, lon: apiPoints[index].lon }
                        }));
                    }
                    throw error;
                }
            });

            const results = await Promise.all(promises);
            let fullProfile = results.flat();

            const startPoint = points[0]; 
            fullProfile.sort((a, b) => {
                const distA = getDistance(startPoint, a.location);
                const distB = getDistance(startPoint, b.location);
                return distA - distB;
            });

            return fullProfile.map((point, index) => ({ ...point, originalIndex: index }));
        }

        function calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz) {
            const worstObstruction = findWorstObstruction(elevationProfile, userAntennaHeight, repeaterAntennaHeight, frequencyMHz);
            return {
                isVisible: !worstObstruction,
                obstructionPoint: worstObstruction,
            };
        }
        
        function calculateFreeSpacePathLoss(distanceKm, frequencyMHz) {
            if (distanceKm <= 0 || frequencyMHz <= 0) {
                return 0;
            }
            const pathLoss = 20 * Math.log10(distanceKm) + 20 * Math.log10(frequencyMHz) + 32.44;
            return pathLoss;
        }
        
        function findWorstObstruction(pathSegment, startAntennaHeight, endAntennaHeight, frequencyMHz) {
            if (!pathSegment || pathSegment.length < 2) {
                return null;
            }
            const applyCurvature = document.getElementById('curvature-checkbox').checked;
            const totalDistanceKm = getDistance(pathSegment[0].location, pathSegment[pathSegment.length - 1].location);
            const totalDistanceM = totalDistanceKm * 1000;

            const startElevation = pathSegment[0].elevation + startAntennaHeight;
            const endElevation = pathSegment[pathSegment.length - 1].elevation + endAntennaHeight;

            let worstObstruction = null;
            let maxIncursion = -Infinity;

            for (let i = 1; i < pathSegment.length - 1; i++) {
                const intermediatePoint = pathSegment[i];
                const pointOriginalIndex = intermediatePoint.originalIndex; 
                
                const d1_km = getDistance(pathSegment[0].location, intermediatePoint.location);
                const d2_km = totalDistanceKm - d1_km;
                const fraction = d1_km / totalDistanceKm;
                
                const terrainElevation = intermediatePoint.elevation;
                const straightLosHeight = startElevation + fraction * (endElevation - startElevation);
                
                let effectiveLosHeight = straightLosHeight;
                if (applyCurvature) {
                    const d1 = totalDistanceM * fraction;
                    const d2 = totalDistanceM - d1;
                    const curvatureDrop = (d1 * d2) / (2 * EFFECTIVE_EARTH_RADIUS);
                    effectiveLosHeight -= curvatureDrop;
                }

                const fresnelRadius = calculateFresnelZoneRadius(d1_km, d2_km, frequencyMHz);
                const requiredClearance = -0.6 * fresnelRadius;

                const incursion = terrainElevation - (effectiveLosHeight + requiredClearance);

                if (incursion > maxIncursion) {
                    maxIncursion = incursion;
                    worstObstruction = {
                        ...intermediatePoint,
                        h: terrainElevation - effectiveLosHeight,
                        fresnelIncursion: incursion,
                        fresnelRadius: fresnelRadius,
                        indexInSegment: i,
                        originalIndex: pointOriginalIndex
                    };
                }
            }

            return maxIncursion > 0 ? worstObstruction : null;
        }

        function calculateFresnelZoneRadius(d1_km, d2_km, frequencyMHz) {
            if (d1_km <= 0 || d2_km <= 0 || frequencyMHz <= 0) return 0;
            const frequencyGHz = frequencyMHz / 1000;
            const totalDistance_km = d1_km + d2_km;
            return 8.656 * Math.sqrt((d1_km * d2_km) / (frequencyGHz * totalDistance_km));
        }

        function getClutterLoss(frequencyMHz) {
            const envType = environmentTypeSelect.value;
            switch(envType) {
                case 'urban': return 20;
                case 'suburban': return 10;
                case 'rural':
                default: return 0;
            }
        }

        function calculateKnifeEdgeDiffractionLoss(h, d1, d2, frequencyMHz) {
            const c = 299792458;
            const frequencyHz = frequencyMHz * 1e6;
            const lambda = c / frequencyHz;

            if (h <= 0 || d1 <= 0 || d2 <= 0) return 0;

            const v = h * Math.sqrt((2 / lambda) * ((1 / d1) + (1 / d2)));
            
            if (v > -0.7) {
                 return 6.9 + 20 * Math.log10(Math.sqrt(Math.pow(v - 0.1, 2) + 1) + v - 0.1);
            }
            return 0;
        }
        
        function calculateDeygoutDiffractionLoss(pathProfile, startHeight, endHeight, frequencyMHz) {
            function getLossAndObstructionsRecursive(subPath, subStartHeight, subEndHeight) {
                if (subPath.length < 3) {
                    return { loss: 0, obstructions: [] };
                }

                const mainObstruction = findWorstObstruction(subPath, subStartHeight, subEndHeight, frequencyMHz);

                if (!mainObstruction) {
                    return { loss: 0, obstructions: [] };
                }

                const totalSubPathDistance = getDistance(subPath[0].location, subPath[subPath.length - 1].location) * 1000;
                const d1 = getDistance(subPath[0].location, mainObstruction.location) * 1000;
                const d2 = totalSubPathDistance - d1;
                const mainLoss = calculateKnifeEdgeDiffractionLoss(mainObstruction.h, d1, d2, frequencyMHz);

                const path1 = subPath.slice(0, mainObstruction.indexInSegment + 1);
                const results1 = getLossAndObstructionsRecursive(path1, subStartHeight, 0);

                const path2 = subPath.slice(mainObstruction.indexInSegment);
                const results2 = getLossAndObstructionsRecursive(path2, 0, subEndHeight);
                
                const totalLoss = mainLoss + results1.loss + results2.loss;
                const allObstructions = [mainObstruction, ...results1.obstructions, ...results2.obstructions];

                return { loss: totalLoss, obstructions: allObstructions };
            }

            const results = getLossAndObstructionsRecursive(pathProfile, startHeight, endHeight);
            
            return {
                totalLoss: results.loss,
                obstructions: results.obstructions
            };
        }

        function calculateBullingtonDiffractionLoss(pathProfile, startHeight, endHeight, frequencyMHz) {
            if (pathProfile.length < 3) return { loss: 0 };
            const applyCurvature = document.getElementById('curvature-checkbox').checked;

            const startPoint = pathProfile[0];
            const endPoint = pathProfile[pathProfile.length - 1];
            const totalDistance = getDistance(startPoint.location, endPoint.location) * 1000;

            const startAntennaElevation = startPoint.elevation + startHeight;
            const endAntennaElevation = endPoint.elevation + endHeight;

            let txHorizon = null, rxHorizon = null;
            let maxTxSlope = -Infinity, maxRxSlope = -Infinity;

            // Find Tx and Rx horizons
            for (let i = 1; i < pathProfile.length - 1; i++) {
                const point = pathProfile[i];
                const distFromTx = getDistance(startPoint.location, point.location) * 1000;
                let pointElevation = point.elevation;
                if (applyCurvature) {
                    const distFromRx = totalDistance - distFromTx;
                    pointElevation += (distFromTx * distFromRx) / (2 * EFFECTIVE_EARTH_RADIUS);
                }

                const txSlope = (pointElevation - startAntennaElevation) / distFromTx;
                if (txSlope > maxTxSlope) {
                    maxTxSlope = txSlope;
                    txHorizon = { ...point, dist: distFromTx, elev: point.elevation };
                }

                const distFromRx = totalDistance - distFromTx;
                const rxSlope = (pointElevation - endAntennaElevation) / distFromRx;
                if (rxSlope > maxRxSlope) {
                    maxRxSlope = rxSlope;
                    rxHorizon = { ...point, dist: distFromTx, elev: point.elevation };
                }
            }
            
            if (!txHorizon || !rxHorizon) return { loss: 0 };

            // Line equations for tangents
            const c_tx = startAntennaElevation;
            const c_rx = endAntennaElevation - maxRxSlope * totalDistance;

            // Intersection point (virtual obstacle)
            const intersectDist = (c_rx - c_tx) / (maxTxSlope - maxRxSlope);
            const intersectElev = maxTxSlope * intersectDist + c_tx;

            // Height of virtual obstacle above LOS path
            const losElevAtIntersect = startAntennaElevation + (intersectDist / totalDistance) * (endAntennaElevation - startAntennaElevation);
            const h = intersectElev - losElevAtIntersect;

            if (h <= 0) return { loss: 0, bullingtonPoint: { x: intersectDist / 1000, y: intersectElev } };

            const d1 = intersectDist;
            const d2 = totalDistance - intersectDist;
            const loss = calculateKnifeEdgeDiffractionLoss(h, d1, d2, frequencyMHz);

            return {
                loss: loss,
                bullingtonPoint: { x: intersectDist / 1000, y: intersectElev },
                txHorizon: { x: txHorizon.dist / 1000, y: txHorizon.elev },
                rxHorizon: { x: rxHorizon.dist / 1000, y: rxHorizon.elev },
            };
        }

        function findCloseApproachSegments(elevationProfile, userAntennaHeight, repeaterAntennaHeight, threshold, frequencyMHz) {
            const segments = [];
            if (elevationProfile.length < 2) return segments;
            const applyCurvature = document.getElementById('curvature-checkbox').checked;
            const totalDistanceKm = getDistance(elevationProfile[0].location, elevationProfile[elevationProfile.length - 1].location);
            const totalDistanceM = totalDistanceKm * 1000;

            const startElevation = elevationProfile[0].elevation + userAntennaHeight;
            const endElevation = elevationProfile[elevationProfile.length - 1].elevation + repeaterAntennaHeight;
            
            let currentSegment = null;

            for (let i = 1; i < elevationProfile.length - 1; i++) {
                const point = elevationProfile[i];
                const d1_km = getDistance(elevationProfile[0].location, point.location);
                const d2_km = totalDistanceKm - d1_km;
                const fraction = d1_km / totalDistanceKm;
                
                const terrainElevation = point.elevation;
                const straightLosHeight = startElevation + fraction * (endElevation - startElevation);
                let effectiveLosHeight = straightLosHeight;
                
                if (applyCurvature) {
                    const d1 = totalDistanceM * fraction;
                    const d2 = totalDistanceM - d1;
                    const curvatureDrop = (d1 * d2) / (2 * EFFECTIVE_EARTH_RADIUS);
                    effectiveLosHeight -= curvatureDrop;
                }
                
                const fresnelRadius = calculateFresnelZoneRadius(d1_km, d2_km, frequencyMHz);
                const clearance = effectiveLosHeight - terrainElevation;

                if (Math.abs(clearance) <= (threshold + fresnelRadius)) {
                    if (!currentSegment) {
                        currentSegment = { start: Math.max(0, i - 1) };
                    }
                } else {
                    if (currentSegment) {
                        currentSegment.end = Math.min(elevationProfile.length - 1, i);
                        segments.push(currentSegment);
                        currentSegment = null;
                    }
                }
            }
            if (currentSegment) {
                currentSegment.end = elevationProfile.length - 1;
                segments.push(currentSegment);
            }
            return segments;
        }

        async function refineElevationProfile(initialProfile, initialPoints, segments) {
            let refinedProfile = [...initialProfile];
            let offset = 0;

            const totalDistanceMeters = getDistance(initialPoints[0], initialPoints[initialPoints.length - 1]) * 1000;
            const distancePerIndex = totalDistanceMeters / (initialPoints.length - 1);
            const expansionIndices = Math.ceil(50 / distancePerIndex);

            for (const segment of segments) {
                const expandedStart = Math.max(0, segment.start - expansionIndices);
                const expandedEnd = Math.min(initialPoints.length - 1, segment.end + expansionIndices);
                
                const startPoint = initialPoints[expandedStart];
                const endPoint = initialPoints[expandedEnd];
                
                const refinedPoints = getPointsOnPath(startPoint, endPoint, 50);
                const refinedSegmentProfile = await getElevationProfile(refinedPoints);

                const pointsToRemove = expandedEnd - expandedStart + 1;
                refinedProfile.splice(expandedStart + offset, pointsToRemove, ...refinedSegmentProfile);
                
                offset += refinedSegmentProfile.length - pointsToRemove;
            }
            return refinedProfile;
        }

        function displaySelectedRepeaterInfo(target) {
            selectedRepeaterInfoDiv.innerHTML = `
                <div class="text-left">
                    <p class="font-bold text-lg">${target.callsign}</p>
                    <p class="text-sm text-gray-600">${target.location}</p>
                    <div class="mt-2 text-sm text-gray-800 grid grid-cols-2 gap-x-4 gap-y-1">
                        <span><span class="font-semibold">Frequency:</span> ${target.outputFreq || target.frequency} MHz</span>
                        <span><span class="font-semibold">Antenna Ht:</span> ${target.antennaHeight} m</span>
                    </div>
                </div>
            `;
        }

        function displayLosResult(isVisible, obstructionPoint, userCoords, target, profileLength) {
            const distance = getDistance(userCoords, target).toFixed(2);
            let resultHTML;
            if (isVisible) {
                resultHTML = `<div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4">
                                        <p class="font-bold text-xl">Line-of-Sight is CLEAR!</p>
                                        <p>The path to ${target.callsign} (${distance} km) has 60% Fresnel Zone clearance.</p>
                                    </div>`;
            } else {
                const profilePoints = profileLength > 1 ? profileLength - 1 : 1;
                const obstructionDist = (distance * (obstructionPoint ? obstructionPoint.originalIndex / profilePoints : 0)).toFixed(2);
                resultHTML = `<div class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4">
                                        <p class="font-bold text-xl">Line-of-Sight is OBSTRUCTED</p>
                                        <p>The path to ${target.callsign} (${distance} km) is blocked by terrain (including 60% Fresnel Zone).</p>
                                        ${obstructionPoint ? `<p>The primary obstruction is approx. ${obstructionDist} km away, with an incursion of ${obstructionPoint.fresnelIncursion.toFixed(1)}m into the zone.</p>` : ''}
                                    </div>`;
            }
            losResultContainer.innerHTML = resultHTML;
        }

        function displayPathLossResult(totalPathLoss, isVisible, target, breakdown) {
            let resultHTML;
            const modelUsed = breakdown.model || 'Unknown Model';

            if (isVisible) {
                resultHTML = `<div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4">
                                        <p class="font-bold text-xl">Total Path Loss (LOS)</p>
                                        <p>Estimated loss to ${target.callsign}: <span class="font-bold text-2xl">${totalPathLoss.toFixed(1)} dB</span></p>
                                        <div class="mt-2 text-sm">
                                            <p>Model Used: ${modelUsed}</p>
                                            <p>Free-Space Path Loss: ${breakdown.fspl.toFixed(1)} dB</p>
                                            <p>+ Clutter Loss: ${breakdown.clutter.toFixed(1)} dB</p>
                                        </div>
                                      </div>`;
            } else {
                resultHTML = `<div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4">
                                        <p class="font-bold text-xl">Total Path Loss (NLOS)</p>
                                        <p>Estimated total loss to ${target.callsign}: <span class="font-bold text-2xl">${totalPathLoss.toFixed(1)} dB</span></p>
                                        <div class="mt-2 text-sm">
                                             <p>Model Used: ${modelUsed}</p>
                                             <p>Free-Space Path Loss: ${breakdown.fspl.toFixed(1)} dB</p>
                                             <p>+ Diffraction Loss: ${breakdown.diffraction.toFixed(1)} dB</p>
                                             <p>+ Clutter Loss: ${breakdown.clutter.toFixed(1)} dB</p>
                                        </div>
                                      </div>`;
            }
            pathLossResultContainer.innerHTML = resultHTML;
        }
        
        function drawProfileChart(elevationData, userAntennaHeight, repeaterAntennaHeight, isVisible, allObstructions, frequencyMHz, bullingtonResult) {
            if (profileChart) {
                profileChart.destroy();
            }
            const applyCurvature = document.getElementById('curvature-checkbox').checked;
            const showFresnel = document.getElementById('fresnel-checkbox').checked;
            
            const distanceData = elevationData.map(p => getDistance(elevationData[0].location, p.location));
            const totalDistanceKm = distanceData[distanceData.length - 1];
            const totalDistanceM = totalDistanceKm * 1000;

            const terrainData = elevationData.map(p => p.elevation);
            const startElevation = terrainData[0] + userAntennaHeight;
            const endElevation = terrainData[terrainData.length - 1] + repeaterAntennaHeight;
            
            const losData = elevationData.map((p, i) => {
                const d1_m = distanceData[i] * 1000;
                const fraction = d1_m / totalDistanceM;
                const straightLosHeight = startElevation + fraction * (endElevation - startElevation);
                
                if (applyCurvature && totalDistanceM > 0) {
                    const d2_m = totalDistanceM - d1_m;
                    const curvatureDrop = (d1_m * d2_m) / (2 * EFFECTIVE_EARTH_RADIUS);
                    return straightLosHeight - curvatureDrop;
                }
                return straightLosHeight;
            });

            const terrainXY = terrainData.map((y, i) => ({ x: distanceData[i], y: y }));
            const losXY = losData.map((y, i) => ({ x: distanceData[i], y: y }));

            const terrainMin = Math.min(...terrainData);
            const terrainMax = Math.max(...terrainData, ...losData);
            const yAxisPadding = (terrainMax - terrainMin) * 0.1 || 50;

            const datasets = [{
                label: 'Terrain Profile',
                data: terrainXY,
                borderColor: 'rgb(139, 69, 19)',
                backgroundColor: 'rgba(139, 69, 19, 0.2)',
                fill: 'origin',
                pointRadius: 0,
                borderWidth: 2,
                showLine: true
            }, {
                label: 'Line of Sight',
                data: losXY,
                borderColor: isVisible ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)',
                fill: false,
                pointRadius: 0,
                borderWidth: 3,
                borderDash: [5, 5],
                showLine: true
            }];
            
            if (showFresnel) {
                const fresnelUpper = [];
                const fresnelLower = [];

                elevationData.forEach((p, i) => {
                    const d1_km = distanceData[i];
                    const d2_km = totalDistanceKm - d1_km;
                    const radius = calculateFresnelZoneRadius(d1_km, d2_km, frequencyMHz);
                    const clearance = 0.6 * radius;
                    fresnelUpper.push({ x: distanceData[i], y: losData[i] + clearance });
                    fresnelLower.push({ x: distanceData[i], y: losData[i] - clearance });
                });

                datasets.push({
                    label: '60% Fresnel Zone',
                    data: fresnelUpper,
                    fill: '+1',
                    backgroundColor: isVisible ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                    borderColor: 'transparent',
                    pointRadius: 0,
                    showLine: true
                });
                 datasets.push({
                    label: 'Fresnel Lower',
                    data: fresnelLower,
                    fill: false,
                    borderColor: 'transparent',
                    pointRadius: 0,
                    showLine: true
                });
            }

            if (allObstructions && allObstructions.length > 0) {
                const obstructionPoints = allObstructions.map((obs) => ({
                    x: getDistance(elevationData[0].location, obs.location),
                    y: obs.elevation
                }));

                datasets.push({
                    label: 'Deygout Obstruction(s)',
                    data: obstructionPoints,
                    backgroundColor: 'rgb(239, 68, 68)',
                    pointRadius: 6,
                    pointStyle: 'crossRot'
                });
            }

            if (bullingtonResult && bullingtonResult.bullingtonPoint) {
                 datasets.push({
                    label: 'Bullington Tangents',
                    data: [
                        {x: 0, y: startElevation},
                        {x: bullingtonResult.txHorizon.x, y: bullingtonResult.txHorizon.y},
                        bullingtonResult.bullingtonPoint,
                        {x: bullingtonResult.rxHorizon.x, y: bullingtonResult.rxHorizon.y},
                        {x: totalDistanceKm, y: endElevation}
                    ],
                    borderColor: 'rgba(128, 0, 128, 0.5)',
                    borderWidth: 2,
                    borderDash: [3,3],
                    pointRadius: 0,
                    showLine: true
                });
                datasets.push({
                    label: 'Bullington Obstacle',
                    data: [bullingtonResult.bullingtonPoint],
                    backgroundColor: 'rgb(128, 0, 128)',
                    pointRadius: 8,
                    pointStyle: 'triangle'
                });
            }

            const ctx = profileChartCanvas.getContext('2d');
            profileChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: 'Elevation Profile' },
                        legend: { position: 'top', labels: { filter: item => item.text && !item.text.includes('Lower') } },
                        tooltip: { callbacks: {
                            title: (context) => `Distance: ${context[0].parsed.x.toFixed(1)} km`,
                            label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(1)} m`
                        }}
                    },
                    scales: {
                        x: { 
                            type: 'linear',
                            title: { display: true, text: 'Distance (km)' },
                            min: 0,
                            max: totalDistanceKm
                        },
                        y: { 
                            title: { display: true, text: 'Elevation (meters)' },
                            min: Math.max(0, Math.floor(terrainMin - yAxisPadding)),
                            suggestedMax: Math.ceil(terrainMax + yAxisPadding)
                        }
                    }
                }
            });
        }

        function drawPathOnMap(points, isVisible) {
            if (pathLine) map.removeLayer(pathLine);
            const latLngs = points.map(p => [p.lat, p.lon]);
            pathLine = L.polyline(latLngs, { color: isVisible ? 'green' : 'red', weight: 4, opacity: 0.8 }).addTo(map);
            map.fitBounds(pathLine.getBounds().pad(0.1));
        }

        function getDistance(coords1, coords2) {
            const R = 6371; // km
            const dLat = (coords2.lat - coords1.lat) * Math.PI / 180;
            const dLon = (coords2.lon - coords1.lon) * Math.PI / 180;
            const lat1 = coords1.lat * Math.PI / 180;
            const lat2 = coords2.lat * Math.PI / 180;

            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
            return R * c;
        }
        
        window.analyzePathFromPopup = analyzePathFromPopup;

        function togglePlaceMarkerMode(mode, id = null) {
            isPlacingMarker = !isPlacingMarker;
            placementInfo.mode = isPlacingMarker ? mode : null;
            placementInfo.id = id;
            
            const mapContainer = document.getElementById('map');
            if (isPlacingMarker) {
                mapContainer.classList.add('crosshair-cursor');
                addMarkerBtn.textContent = 'Cancel Placement';
                addMarkerBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                addMarkerBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                if (placementInfo.mode === 'custom') {
                    customMarkerInputContainer.classList.remove('hidden');
                }
            } else {
                mapContainer.classList.remove('crosshair-cursor');
                addMarkerBtn.textContent = 'Place Custom Marker';
                addMarkerBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                addMarkerBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                customMarkerInputContainer.classList.add('hidden');
            }
        }

        function onMapClick(e) {
            if (!isPlacingMarker) return;
            
            if (placementInfo.mode === 'custom') {
                const name = customMarkerNameInput.value.trim() || `Custom Marker ${customMarkers.length + 1}`;
                const newMarkerData = {
                    id: `custom-${Date.now()}`,
                    callsign: name,
                    lat: e.latlng.lat,
                    lon: e.latlng.lng,
                    location: `Custom Marker (${e.latlng.lat.toFixed(3)}, ${e.latlng.lng.toFixed(3)})`,
                    antennaHeight: parseFloat(repeaterHeightInput.value) || 30,
                    frequency: parseFloat(customMarkerFreqInput.value) || 146.520
                };
                customMarkers.push(newMarkerData);
                displayCustomMarkers();
                customMarkerNameInput.value = '';
            } else if (placementInfo.mode === 'repeater') {
                const repeater = repeaterData.find(r => r.id === placementInfo.id);
                if (repeater) {
                    repeater.lat = e.latlng.lat;
                    repeater.lon = e.latlng.lng;
                    delete repeater.locationUnknown;
                    updateFilteredView(repeaterData, getCurrentCoords());
                }
            }
            
            togglePlaceMarkerMode(null);
        }

        function displayCustomMarkers() {
            customListDiv.innerHTML = '';
            customMarkerLayer.clearLayers();

            if (customMarkers.length === 0) {
                customListDiv.innerHTML = '<p class="p-3 text-gray-500">Click "Place Custom Marker" to add locations.</p>';
            }

            customMarkers.forEach(markerData => {
                const userCoords = getCurrentCoords();
                const distance = getDistance(userCoords, markerData).toFixed(1);

                const item = document.createElement('div');
                item.className = 'p-3 border rounded-lg hover:bg-gray-100';
                item.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="flex-grow cursor-pointer" data-id="${markerData.id}">
                            <p class="font-bold">${markerData.callsign}</p>
                            <p class="text-sm text-gray-600">${markerData.location} (${distance} km)</p>
                        </div>
                        <button class="delete-custom-marker text-red-500 hover:text-red-700 font-bold ml-2 p-1">&times;</button>
                    </div>
                     <div class="mt-1 grid grid-cols-2 gap-x-4">
                        <div>
                            <label for="height-${markerData.id}" class="text-xs font-medium">Antenna Ht (m):</label>
                            <input type="number" id="height-${markerData.id}" value="${markerData.antennaHeight}" class="w-full mt-1 px-1 py-0.5 text-xs border border-gray-300 rounded">
                        </div>
                        <div>
                            <label for="freq-${markerData.id}" class="text-xs font-medium">Frequency (MHz):</label>
                            <input type="number" id="freq-${markerData.id}" value="${markerData.frequency}" class="w-full mt-1 px-1 py-0.5 text-xs border border-gray-300 rounded">
                        </div>
                    </div>
                `;
                item.querySelector('.flex-grow').onclick = () => analyzePath(markerData, userCoords);
                item.querySelector('.delete-custom-marker').onclick = (e) => {
                    e.stopPropagation();
                    deleteCustomMarker(markerData.id);
                };

                const heightInput = item.querySelector(`#height-${markerData.id}`);
                heightInput.addEventListener('input', (e) => {
                    const newHeight = parseFloat(e.target.value);
                    const targetMarker = customMarkers.find(m => m.id === markerData.id);
                    if (targetMarker && !isNaN(newHeight)) {
                        targetMarker.antennaHeight = newHeight;
                        if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerData.id) {
                            analyzePath(targetMarker, getCurrentCoords());
                        }
                    }
                });
                
                const freqInput = item.querySelector(`#freq-${markerData.id}`);
                freqInput.addEventListener('input', (e) => {
                    const newFreq = parseFloat(e.target.value);
                    const targetMarker = customMarkers.find(m => m.id === markerData.id);
                    if (targetMarker && !isNaN(newFreq)) {
                        targetMarker.frequency = newFreq;
                        if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerData.id) {
                            analyzePath(targetMarker, getCurrentCoords());
                        }
                    }
                });

                customListDiv.appendChild(item);

                const marker = L.marker([markerData.lat, markerData.lon], {
                    draggable: true,
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                    })
                }).addTo(customMarkerLayer);
                
                marker.on('dragend', (event) => {
                    const newCoords = event.target.getLatLng();
                    markerData.lat = newCoords.lat;
                    markerData.lon = newCoords.lng;
                    markerData.location = `Custom Marker (${newCoords.lat.toFixed(3)}, ${newCoords.lng.toFixed(3)})`;
                    displayCustomMarkers();
                    if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerData.id) {
                        analyzePath(markerData, getCurrentCoords());
                    }
                });
            });
        }
        
        function deleteCustomMarker(markerId) {
            const index = customMarkers.findIndex(m => m.id === markerId);
            if (index > -1) {
                if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerId) {
                    lastAnalyzedTarget = null;
                    if (repeaterMarker) map.removeLayer(repeaterMarker);
                    repeaterMarker = null;
                    if (pathLine) map.removeLayer(pathLine);
                    if (profileChart) profileChart.destroy();
                    losResultContainer.innerHTML = '<p class="p-3 text-gray-500">Select a target from the list to analyze the path.</p>';
                    selectedRepeaterInfoDiv.innerHTML = '<p class="text-gray-500">Select a target to see its details here.</p>';
                }
                customMarkers.splice(index, 1);
                displayCustomMarkers();
            }
        }
        
        function clearLocalStorage() {
            if(confirm("Are you sure you want to delete all saved data? This cannot be undone.")) {
                localStorage.clear();
                window.location.reload();
            }
        }

        function getSetNameInput() {
            const desktopInput = document.getElementById('set-name-input-desktop');
            const mobileInput = document.getElementById('set-name-input-mobile');
            return window.innerWidth < 1024 ? mobileInput : desktopInput;
        }

        function getSetSelect() {
            const desktopSelect = document.getElementById('set-select-desktop');
            const mobileSelect = document.getElementById('set-select-mobile');
            return window.innerWidth < 1024 ? mobileSelect : desktopSelect;
        }

        function showSetErrorMessage(show) {
             document.getElementById('set-error-msg-desktop').classList.toggle('hidden', !show);
             document.getElementById('set-error-msg-mobile').classList.toggle('hidden', !show);
        }

        function saveCurrentSet() {
            const setNameInput = getSetNameInput();
            const setName = setNameInput.value.trim();
            if (!setName) {
                showSetErrorMessage(true);
                return;
            }
            showSetErrorMessage(false);

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            savedSets[setName] = {
                repeaterData: repeaterData,
                customMarkers: customMarkers
            };

            localStorage.setItem('repeaterSets', JSON.stringify(savedSets));
            localStorage.setItem('lastRepeaterSet', setName);
            updateSetSelector(Object.keys(savedSets), setName);
            setNameInput.value = '';
            filterStatusDiv.textContent = `Set "${setName}" saved.`;
            setTimeout(() => filterStatusDiv.textContent = '', 3000);
        }

        function deleteCurrentSet() {
            const setSelect = getSetSelect();
            const setName = setSelect.value;
            if (!setName) {
                filterStatusDiv.textContent = "No set selected to delete.";
                setTimeout(() => filterStatusDiv.textContent = '', 3000);
                return;
            }

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            delete savedSets[setName];
            localStorage.setItem('repeaterSets', JSON.stringify(savedSets));
            
            if (localStorage.getItem('lastRepeaterSet') === setName) {
                localStorage.removeItem('lastRepeaterSet');
            }
            
            window.location.reload();
        }

        function loadSelectedSet(event) {
            const setName = event.target.value;
            if (!setName) return;

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            if (savedSets[setName]) {
                localStorage.setItem('lastRepeaterSet', setName);
                window.location.reload();
            }
        }

        function loadFromLocalStorage() {
            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            const lastSetName = localStorage.getItem('lastRepeaterSet');
            
            updateSetSelector(Object.keys(savedSets), lastSetName);

            if (lastSetName && savedSets[lastSetName]) {
                repeaterData = savedSets[lastSetName].repeaterData || [];
                customMarkers = savedSets[lastSetName].customMarkers || [];

                filterStatusDiv.textContent = `Loaded set: ${lastSetName}`;
                updateFilteredView(repeaterData, getCurrentCoords());
            }
        }

        function updateSetSelector(setNames, currentSet) {
            ['desktop', 'mobile'].forEach(view => {
                const setSelect = document.getElementById(`set-select-${view}`);
                setSelect.innerHTML = '<option value="">Select a set...</option>';
                setNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    if (name === currentSet) {
                        option.selected = true;
                    }
                    setSelect.appendChild(option);
                });
            });
        }

        function handleDefaultRepeaterHeightChange(e) {
            const newDefaultHeight = parseFloat(e.target.value);
            if (isNaN(newDefaultHeight)) return;

            repeaterData.forEach(repeater => {
                if (repeater.antennaHeight === previousDefaultRepeaterHeight) {
                    repeater.antennaHeight = newDefaultHeight;
                }
            });
            
             customMarkers.forEach(marker => {
                if (marker.antennaHeight === previousDefaultRepeaterHeight) {
                    marker.antennaHeight = newDefaultHeight;
                }
            });

            updateFilteredView(repeaterData, getCurrentCoords());
            displayCustomMarkers();

            if (lastAnalyzedTarget) {
                const currentTargetData = repeaterData.find(r => r.id === lastAnalyzedTarget.id) || customMarkers.find(m => m.id === lastAnalyzedTarget.id);
                if(currentTargetData) {
                   analyzePath(currentTargetData, getCurrentCoords());
                }
            }
            
            previousDefaultRepeaterHeight = newDefaultHeight;
        }

    </script>
</body>
</html>

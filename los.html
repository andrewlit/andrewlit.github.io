<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio LOS Tool</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LeafletJS for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Leaflet MarkerCluster for avoiding marker overlap -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

    <!-- Chart.js for profile visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        /* Set a default font and ensure the map container has a defined height */
        body {
            font-family: 'Inter', sans-serif;
        }
        #map {
            height: 500px; /* Increased height for better view */
            border-radius: 0.5rem;
            z-index: 10;
        }
        /* Custom styles for Leaflet popups */
        .leaflet-popup-content-wrapper {
            border-radius: 0.5rem;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .crosshair-cursor {
            cursor: crosshair !important;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Radio LOS Tool</h1>
            <p class="text-lg text-gray-600 mt-2">Upload a GPX file to analyze repeater line-of-sight.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: Controls and Repeater List -->
            <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-lg">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Controls</h2>
                
                <div class="space-y-4">
                    <div>
                        <label for="gpx-upload" class="block text-sm font-medium text-gray-700">Upload Repeaterbook GPX</label>
                        <input type="file" id="gpx-upload" accept=".gpx" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
                    </div>
                    <div>
                        <label for="latitude" class="block text-sm font-medium text-gray-700">Your Latitude</label>
                        <input type="number" id="latitude" placeholder="e.g., 43.653" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div>
                        <label for="longitude" class="block text-sm font-medium text-gray-700">Your Longitude</label>
                        <input type="number" id="longitude" placeholder="e.g., -79.383" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                     <div>
                        <label for="user-height" class="block text-sm font-medium text-gray-700">Your Antenna Height (meters)</label>
                        <input type="number" id="user-height" value="10" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div>
                        <label for="repeater-height" class="block text-sm font-medium text-gray-700">Default Repeater Antenna Height (meters)</label>
                        <input type="number" id="repeater-height" value="10" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div class="flex space-x-2">
                         <button id="resetLocationBtn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300">Reset to My Location</button>
                         <button id="addMarkerBtn" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300">Place Custom Marker</button>
                    </div>
                    <div id="custom-marker-input-container" class="hidden space-y-2 mt-2 border-t pt-4">
                        <label for="custom-marker-name" class="block text-sm font-medium text-gray-700">Custom Marker Name (optional)</label>
                        <input type="text" id="custom-marker-name" placeholder="Enter name and click map..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    </div>
                </div>
                
                <h2 class="text-2xl font-semibold mt-8 mb-4 border-b pb-2">Nearby Repeaters</h2>
                <div class="mb-4">
                    <input type="text" id="repeater-search" placeholder="Search callsign, freq, location..." class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="flex items-center mb-4">
                    <input id="los-filter-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="los-filter-checkbox" class="ml-2 block text-sm text-gray-900">Show only repeaters with Line-of-Sight</label>
                </div>
                <div id="filter-status" class="text-sm text-gray-600 mb-2"></div>
                <div id="repeater-list" class="space-y-2 max-h-60 overflow-y-auto">
                    <p class="p-3 text-gray-500">Upload a GPX file or load a set to see repeater data.</p>
                </div>

                <h2 class="text-2xl font-semibold mt-4 mb-4 border-b pb-2">Custom Locations</h2>
                <div id="custom-list" class="space-y-2 max-h-40 overflow-y-auto">
                     <p class="p-3 text-gray-500">Click "Place Custom Marker" to add locations.</p>
                </div>

                <!-- Manage Sets for Desktop -->
                <div class="hidden lg:block mt-8 border-t pt-4">
                    <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Manage Sets</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="set-select-desktop" class="block text-sm font-medium text-gray-700">Load Set</label>
                            <select id="set-select-desktop" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                        </div>
                        <div>
                            <label for="set-name-input-desktop" class="block text-sm font-medium text-gray-700">New Set Name</label>
                            <input type="text" id="set-name-input-desktop" placeholder="Enter name to save..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                            <p id="set-error-msg-desktop" class="text-red-500 text-xs hidden mt-1">Please enter a name for the set.</p>
                        </div>
                        <div class="flex space-x-2">
                            <button id="saveSetBtn-desktop" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300">Save Current Set</button>
                            <button id="deleteSetBtn-desktop" class="w-full bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-700 transition duration-300">Delete Selected Set</button>
                        </div>
                         <div id="delete-confirmation-desktop" class="hidden space-y-2 mt-2 border-t pt-4">
                            <p class="text-sm text-center font-semibold">Are you sure? This is permanent.</p>
                             <div class="flex space-x-2">
                                <button id="confirmDeleteBtn-desktop" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">Yes, Delete</button>
                                <button id="cancelDeleteBtn-desktop" class="w-full bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400">Cancel</button>
                             </div>
                        </div>
                         <div>
                            <button id="clearDataBtn-desktop" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 mt-4">Clear All Saved Data</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Map and Results -->
            <div class="lg:col-span-2 bg-white p-6 rounded-lg shadow-lg">
                <div id="map" class="mb-6 border border-gray-200"></div>
                
                <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Selected Repeater Details</h2>
                <div id="selected-repeater-info" class="p-4 rounded-lg bg-gray-50">
                    <p class="text-gray-500">Select a repeater to see its details here.</p>
                </div>

                <h2 class="text-2xl font-semibold mt-6 mb-4 border-b pb-2">Line-of-Sight Analysis</h2>
                <div id="los-result-container" class="text-center p-4 rounded-lg bg-gray-50">
                     <p class="text-gray-500">Select a repeater from the list to analyze the path.</p>
                </div>
                
                <div class="mt-6">
                    <canvas id="profileChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Manage Sets for Mobile -->
        <div class="lg:hidden mt-8 bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Manage Sets</h2>
            <div class="space-y-4">
                <div>
                    <label for="set-select-mobile" class="block text-sm font-medium text-gray-700">Load Set</label>
                    <select id="set-select-mobile" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
                </div>
                <div>
                    <label for="set-name-input-mobile" class="block text-sm font-medium text-gray-700">New Set Name</label>
                    <input type="text" id="set-name-input-mobile" placeholder="Enter name to save..." class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    <p id="set-error-msg-mobile" class="text-red-500 text-xs hidden mt-1">Please enter a name for the set.</p>
                </div>
                <div class="flex space-x-2">
                    <button id="saveSetBtn-mobile" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300">Save Current Set</button>
                    <button id="deleteSetBtn-mobile" class="w-full bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-700 transition duration-300">Delete Selected Set</button>
                </div>
                 <div id="delete-confirmation-mobile" class="hidden space-y-2 mt-2 border-t pt-4">
                    <p class="text-sm text-center font-semibold">Are you sure? This is permanent.</p>
                     <div class="flex space-x-2">
                        <button id="confirmDeleteBtn-mobile" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700">Yes, Delete</button>
                        <button id="cancelDeleteBtn-mobile" class="w-full bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400">Cancel</button>
                     </div>
                </div>
                 <div>
                    <button id="clearDataBtn-mobile" class="w-full bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 mt-4">Clear All Saved Data</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        let repeaterData = [];
        let customMarkers = [];
        let isPlacingMarker = false;
        let lastAnalyzedTarget = null;
        let placementInfo = { mode: null, id: null }; // 'custom' or 'repeater'
        let previousDefaultRepeaterHeight = 30;
        let analysisController = null; // To manage and cancel ongoing batch analyses
        const DEFAULT_LAT = 43.6532; // Downtown Toronto
        const DEFAULT_LON = -79.3832;
        const CANADIAN_PROVINCES = {
            'alberta': '48', 'british columbia': '59', 'manitoba': '46', 'new brunswick': '13', 
            'newfoundland and labrador': '10', 'nova scotia': '12', 'ontario': '35', 
            'prince edward island': '11', 'quebec': '24', 'saskatchewan': '47', 
            'northwest territories': '61', 'nunavut': '62', 'yukon': '60'
        };

        // --- DOM Element References ---
        let latInput, lonInput, userHeightInput, repeaterHeightInput, gpxUpload,
            addMarkerBtn, resetLocationBtn,
            customMarkerInputContainer, customMarkerNameInput, losFilterCheckbox, filterStatusDiv,
            repeaterListDiv, customListDiv, losResultContainer, selectedRepeaterInfoDiv,
            profileChartCanvas, repeaterSearchInput;

        // --- Map and Chart Initialization ---
        let map;
        let userMarker, repeaterMarker, pathLine;
        let profileChart;
        let markerClusterGroup;
        let customMarkerLayer;
        const TILE_URL = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        const TILE_ATTRIBUTION = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            // Assign DOM elements
            latInput = document.getElementById('latitude');
            lonInput = document.getElementById('longitude');
            userHeightInput = document.getElementById('user-height');
            repeaterHeightInput = document.getElementById('repeater-height');
            gpxUpload = document.getElementById('gpx-upload');
            addMarkerBtn = document.getElementById('addMarkerBtn');
            resetLocationBtn = document.getElementById('resetLocationBtn');
            customMarkerInputContainer = document.getElementById('custom-marker-input-container');
            customMarkerNameInput = document.getElementById('custom-marker-name');
            losFilterCheckbox = document.getElementById('los-filter-checkbox');
            filterStatusDiv = document.getElementById('filter-status');
            repeaterListDiv = document.getElementById('repeater-list');
            customListDiv = document.getElementById('custom-list');
            losResultContainer = document.getElementById('los-result-container');
            selectedRepeaterInfoDiv = document.getElementById('selected-repeater-info');
            profileChartCanvas = document.getElementById('profileChart');
            repeaterSearchInput = document.getElementById('repeater-search');
            
            // Initialize map
            map = L.map('map').setView([DEFAULT_LAT, DEFAULT_LON], 9);
            L.tileLayer(TILE_URL, { attribution: TILE_ATTRIBUTION }).addTo(map);

            customMarkerLayer = L.layerGroup().addTo(map);

            // Set initial location and load data
            setLocation(DEFAULT_LAT, DEFAULT_LON);
            requestUserGeolocation();
            loadFromLocalStorage();

            // Attach event listeners
            map.on('click', onMapClick);
            gpxUpload.addEventListener('change', handleFileUpload);
            losFilterCheckbox.addEventListener('change', handleLOSFilterToggle);
            addMarkerBtn.addEventListener('click', () => togglePlaceMarkerMode('custom'));
            resetLocationBtn.addEventListener('click', requestUserGeolocation);
            userHeightInput.addEventListener('input', () => { if (lastAnalyzedTarget) analyzePath(lastAnalyzedTarget, getCurrentCoords()); });
            repeaterSearchInput.addEventListener('input', () => displayRepeaters(repeaterData, getCurrentCoords()));
            
            repeaterHeightInput.addEventListener('focus', (e) => {
                previousDefaultRepeaterHeight = parseFloat(e.target.value) || 30;
            });
            repeaterHeightInput.addEventListener('input', handleDefaultRepeaterHeightChange);
            
            // --- Event Listeners for both Desktop and Mobile "Manage Sets" ---
            ['desktop', 'mobile'].forEach(view => {
                document.getElementById(`saveSetBtn-${view}`).addEventListener('click', saveCurrentSet);
                document.getElementById(`deleteSetBtn-${view}`).addEventListener('click', () => {
                    document.getElementById(`delete-confirmation-${view}`).classList.remove('hidden');
                });
                document.getElementById(`confirmDeleteBtn-${view}`).addEventListener('click', deleteCurrentSet);
                document.getElementById(`cancelDeleteBtn-${view}`).addEventListener('click', () => {
                     document.getElementById(`delete-confirmation-${view}`).classList.add('hidden');
                });
                document.getElementById(`set-select-${view}`).addEventListener('change', loadSelectedSet);
                document.getElementById(`clearDataBtn-${view}`).addEventListener('click', clearLocalStorage);
            });
        });


        // --- Core Functions ---
        
        function requestUserGeolocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    setLocation(position.coords.latitude, position.coords.longitude);
                }, () => {
                    console.warn('Could not retrieve user location. Using default.');
                });
            }
        }

        function setLocation(lat, lon) {
            latInput.value = lat.toFixed(5);
            lonInput.value = lon.toFixed(5);
            updateUserMarker(lat, lon);
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            repeaterListDiv.innerHTML = `<div class="p-3"><div class="flex items-center"><div class="loading-spinner !w-4 !h-4 mr-2"></div><span>Parsing GPX...</span></div></div>`;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    repeaterData = parseGPX(e.target.result);
                    filterStatusDiv.textContent = `Loaded ${repeaterData.length} repeaters. Please save this as a new set.`;
                    displayRepeaters(repeaterData, getCurrentCoords());
                    if (losFilterCheckbox.checked) {
                        runLOSFilterAnalysis();
                    }
                } catch (error) {
                    filterStatusDiv.textContent = `Error parsing GPX: ${error.message}`;
                    repeaterListDiv.innerHTML = '<p class="p-3 text-red-500">Failed to parse GPX file. Please check format.</p>';
                }
            };
            reader.readAsText(file);
        }

        function parseGPX(gpxString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxString, "text/xml");
            const waypoints = xmlDoc.getElementsByTagName("wpt");
            const data = [];
            const defaultHeight = parseFloat(repeaterHeightInput.value) || 30;

            for (let i = 0; i < waypoints.length; i++) {
                const wpt = waypoints[i];
                const nameNode = wpt.getElementsByTagName("name")[0];
                const cmtNode = wpt.getElementsByTagName("cmt")[0];
                
                if (!nameNode || !cmtNode) continue;
                
                const nameStr = nameNode.textContent;
                const parts = nameStr.split(/\s+/);

                let callsign = parts[0] || 'N/A';
                let outputFreqStr = 'N/A';
                let offsetSign = 'N/A';
                let uplinkTone = 'N/A';

                const infoParts = parts.slice(1);
                let freqIndex = -1;

                // First, find the frequency. It's the most distinct part (e.g., > 20 MHz).
                for (let j = 0; j < infoParts.length; j++) {
                    const part = infoParts[j];
                    const num = parseFloat(part);
                    if (!isNaN(num) && num > 20) {
                        outputFreqStr = part.replace(/[+-]$/, ''); // Clean trailing +/-
                        if (part.endsWith('+') || part.endsWith('-')) {
                            offsetSign = part.slice(-1);
                        }
                        freqIndex = j;
                        break;
                    }
                }

                // If we found a frequency, remove it and process the rest.
                if (freqIndex !== -1) {
                    infoParts.splice(freqIndex, 1);
                }

                // Now, look for a standalone offset and a tone in the remaining parts.
                for (const part of infoParts) {
                    if (part === '+' || part === '-') {
                        offsetSign = part; // This will overwrite an attached sign, which is fine.
                    } else {
                        // Anything else is assumed to be the tone.
                        uplinkTone = part;
                    }
                }

                const outputFreq = parseFloat(outputFreqStr);
                let inputFreq = 'N/A';

                // Calculate input frequency if we have all the necessary parts.
                if (!isNaN(outputFreq) && (offsetSign === '+' || offsetSign === '-')) {
                    let standardOffset = 0.6; // Default to VHF 2m offset
                    if (outputFreq >= 440 && outputFreq <= 450) {
                        standardOffset = 5.0; // UHF 70cm offset
                    } else if (outputFreq >= 222 && outputFreq <= 225) {
                        standardOffset = 1.6; // 1.25m band offset
                    }

                    if (offsetSign === '+') {
                        inputFreq = (outputFreq + standardOffset).toFixed(4);
                    } else {
                        inputFreq = (outputFreq - standardOffset).toFixed(4);
                    }
                }

                data.push({
                    id: `repeater-${i}`,
                    lat: parseFloat(wpt.getAttribute("lat")),
                    lon: parseFloat(wpt.getAttribute("lon")),
                    callsign: callsign,
                    outputFreq: outputFreqStr,
                    inputFreq: inputFreq,
                    offset: offsetSign,
                    uplinkTone: uplinkTone,
                    antennaHeight: defaultHeight,
                    location: cmtNode.textContent.replace(callsign, '').replace('OPEN', '').trim()
                });
            }
            return data;
        }
        
        const delay = ms => new Promise(res => setTimeout(res, ms));

        function handleLOSFilterToggle(event) {
            if (analysisController) {
                analysisController.abort();
            }
            localStorage.setItem('losFilterState', event.target.checked);
            if (repeaterData.length === 0) {
                if(event.target.checked) {
                    filterStatusDiv.textContent = "Please upload a repeater GPX file first.";
                    setTimeout(() => filterStatusDiv.textContent = '', 3000);
                }
                event.target.checked = false;
                return;
            }

            if (event.target.checked) {
                if (repeaterData.every(r => typeof r.isVisible === 'boolean' || r.locationUnknown)) {
                    const visibleRepeaters = repeaterData.filter(r => r.isVisible);
                    filterStatusDiv.textContent = `Showing ${visibleRepeaters.length} of ${repeaterData.length} repeaters with clear Line-of-Sight.`;
                    displayRepeaters(visibleRepeaters, getCurrentCoords());
                } else {
                    runLOSFilterAnalysis();
                }
            } else {
                filterStatusDiv.textContent = '';
                displayRepeaters(repeaterData, getCurrentCoords());
            }
        }

        async function runLOSFilterAnalysis() {
            // Cancel any previous analysis that might be running
            if (analysisController) {
                analysisController.abort();
            }
            analysisController = new AbortController();
            const signal = analysisController.signal;

            const userCoords = getCurrentCoords();
            let completedCount = 0;
            const repeatersToAnalyze = repeaterData.filter(r => !r.locationUnknown);
            const totalRepeaters = repeatersToAnalyze.length;
            let visibleRepeaters = [];
            const startTime = Date.now();

            displayRepeaters([], userCoords);

            const concurrencyLimit = 8;
            const queue = [...repeatersToAnalyze];
            
            const worker = async () => {
                while(queue.length > 0) {
                    if (signal.aborted) return; // Stop if cancelled
                    const repeater = queue.shift();
                    if (!repeater) continue;

                    const result = await getLOSForRepeater(repeater, userCoords);
                    if (signal.aborted) return;

                    repeater.isVisible = result.isVisible;
                    completedCount++;

                    if (repeater.isVisible) {
                        visibleRepeaters.push(repeater);
                        visibleRepeaters.sort((a, b) => getDistance(userCoords, a) - getDistance(userCoords, b));
                        displayRepeaters([...visibleRepeaters], userCoords);
                    }
                    
                    const elapsedTime = Date.now() - startTime;
                    const avgTime = elapsedTime / completedCount;
                    const remainingTime = avgTime * (totalRepeaters - completedCount);
                    const formattedTime = formatRemainingTime(remainingTime);

                    filterStatusDiv.innerHTML = `<div class="flex items-center"><div class="loading-spinner !w-4 !h-4 mr-2"></div><span>Analyzed ${completedCount} of ${totalRepeaters}... Found ${visibleRepeaters.length} with LOS. (Est. ${formattedTime} left)</span></div>`;
                }
            };

            const workers = Array(concurrencyLimit).fill(null).map(worker);
            
            try {
                await Promise.all(workers);
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Batch analysis was cancelled.');
                    return;
                }
                throw error;
            }

            if (signal.aborted) return;

            localStorage.setItem('repeaterData', JSON.stringify(repeaterData));
            filterStatusDiv.textContent = `Showing ${visibleRepeaters.length} of ${totalRepeaters} repeaters with clear Line-of-Sight.`;
            displayRepeaters(visibleRepeaters, userCoords);
        }

        function formatRemainingTime(ms) {
            if (ms < 1000) return "< 1s";
            let totalSeconds = Math.round(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            }
            return `${seconds}s`;
        }


        async function getLOSForRepeater(repeater, userCoords) {
            try {
                const initialPoints = getPointsOnPath(userCoords, { lat: repeater.lat, lon: repeater.lon }, 100);
                let elevationProfile = await getElevationProfile(initialPoints);
                const userAntennaHeight = parseFloat(userHeightInput.value) || 10;
                const repeaterAntennaHeight = parseFloat(repeater.antennaHeight) || parseFloat(repeaterHeightInput.value) || 30;
                
                let { isVisible } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight);

                // Adaptive sampling for batch operation
                if (isVisible) {
                    const closeApproachSegments = findCloseApproachSegments(elevationProfile, userAntennaHeight, repeaterAntennaHeight, 20);
                    if (closeApproachSegments.length > 0) {
                        elevationProfile = await refineElevationProfile(elevationProfile, initialPoints, closeApproachSegments);
                        ({ isVisible } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight));
                    }
                }
                return { repeater, isVisible };
            } catch (error) {
                console.error(`Failed to analyze LOS for ${repeater.callsign}:`, error);
                return { repeater, isVisible: false };
            }
        }
        
        function displayRepeaters(repeaters, userCoords) {
            const searchTerm = repeaterSearchInput.value.toLowerCase();
            let dataToDisplay = repeaters;

            if (searchTerm) {
                dataToDisplay = repeaters.filter(r => 
                    r.callsign.toLowerCase().includes(searchTerm) ||
                    r.outputFreq.includes(searchTerm) ||
                    r.inputFreq.includes(searchTerm) ||
                    r.location.toLowerCase().includes(searchTerm)
                );
            }

            const knownRepeaters = dataToDisplay.filter(r => !r.locationUnknown);
            repeaterListDiv.innerHTML = '';
            
            if (markerClusterGroup) {
                markerClusterGroup.clearLayers();
            } else {
                markerClusterGroup = L.markerClusterGroup();
                map.addLayer(markerClusterGroup);
            }

            if (knownRepeaters.length === 0 && losFilterCheckbox.checked) {
                 repeaterListDiv.innerHTML = '<p class="p-3 text-gray-500">No repeaters found with Line-of-Sight.</p>';
            } else if (knownRepeaters.length === 0) {
                 repeaterListDiv.innerHTML = '<p class="p-3 text-gray-500">No repeaters match your search.</p>';
            }


            knownRepeaters.sort((a, b) => getDistance(userCoords, a) - getDistance(userCoords, b));

            knownRepeaters.forEach(repeater => {
                const distance = getDistance(userCoords, repeater).toFixed(1);
                const item = document.createElement('div');
                item.className = 'p-3 border rounded-lg hover:bg-gray-100';
                item.innerHTML = `
                    <div class="flex justify-between items-start cursor-pointer" data-repeater-id="${repeater.id}">
                        <div>
                            <p class="font-bold">${repeater.callsign}</p>
                            <p class="text-sm text-gray-600">${repeater.location}</p>
                        </div>
                        <p class="text-sm font-medium text-gray-800">${distance} km</p>
                    </div>
                    <div class="mt-2 text-xs text-gray-700 grid grid-cols-2 gap-x-4 gap-y-1">
                        <span><span class="font-semibold">Output:</span> ${repeater.outputFreq} (${repeater.offset})</span>
                        <span><span class="font-semibold">Input:</span> ${repeater.inputFreq}</span>
                        ${repeater.uplinkTone !== 'N/A' ? `<span><span class="font-semibold">Tone:</span> ${repeater.uplinkTone}</span>` : ''}
                        <div class="col-span-2 mt-1">
                            <label for="height-${repeater.id}" class="text-xs font-medium">Antenna Ht (m):</label>
                            <input type="number" id="height-${repeater.id}" value="${repeater.antennaHeight}" class="w-20 ml-1 px-1 py-0.5 text-xs border border-gray-300 rounded">
                        </div>
                    </div>
                `;
                item.querySelector(`[data-repeater-id="${repeater.id}"]`).onclick = () => analyzePath(repeater, getCurrentCoords());
                
                const heightInput = item.querySelector(`#height-${repeater.id}`);
                heightInput.addEventListener('input', (e) => {
                    const newHeight = parseFloat(e.target.value);
                    const targetRepeater = repeaterData.find(r => r.id === repeater.id);
                    if (targetRepeater && !isNaN(newHeight)) {
                        targetRepeater.antennaHeight = newHeight;
                        if (lastAnalyzedTarget && lastAnalyzedTarget.id === repeater.id) {
                            analyzePath(targetRepeater, getCurrentCoords());
                        }
                    }
                });

                repeaterListDiv.appendChild(item);

                const marker = L.marker([repeater.lat, repeater.lon], { draggable: true })
                    .bindPopup(`<b>${repeater.callsign}</b><br>${repeater.location}<br>${repeater.outputFreq} MHz<br><button class="mt-2 p-1 bg-indigo-500 text-white rounded text-xs" onclick='analyzePathFromPopup(${JSON.stringify(repeater)})'>Check LOS</button>`);
                
                marker.on('dragend', (event) => {
                    const newCoords = event.target.getLatLng();
                    repeater.lat = newCoords.lat;
                    repeater.lon = newCoords.lng;
                    repeater.location = `Custom Position (${newCoords.lat.toFixed(3)}, ${newCoords.lng.toFixed(3)})`;
                    displayRepeaters(repeaterData, getCurrentCoords());
                    if (lastAnalyzedTarget && lastAnalyzedTarget.id === repeater.id) {
                        analyzePath(repeater, getCurrentCoords());
                    }
                });

                markerClusterGroup.addLayer(marker);
            });
        }
        
        function analyzePathFromPopup(repeater) {
            // Find the full repeater object from our data array to get the latest height
            const fullRepeaterData = repeaterData.find(r => r.id === repeater.id);
            if(fullRepeaterData) {
                analyzePath(fullRepeaterData, getCurrentCoords());
            }
            map.closePopup();
        }

        function updateUserMarker(lat, lon) {
            if (userMarker) {
                map.removeLayer(userMarker);
            }
            userMarker = L.marker([lat, lon], {
                draggable: true,
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                })
            }).addTo(map);

            userMarker.bindPopup('Your Location').openPopup();
            map.setView([lat, lon], 9);

            userMarker.on('dragend', function(event) {
                if (analysisController) {
                    analysisController.abort();
                }
                const newCoords = event.target.getLatLng();
                const standardizedCoords = { lat: newCoords.lat, lon: newCoords.lng };
                latInput.value = standardizedCoords.lat.toFixed(5);
                lonInput.value = standardizedCoords.lon.toFixed(5);
                
                repeaterData.forEach(r => delete r.isVisible);
                localStorage.setItem('repeaterData', JSON.stringify(repeaterData));

                displayRepeaters(repeaterData, standardizedCoords);
                displayCustomMarkers();
                if (lastAnalyzedTarget) {
                    analyzePath(lastAnalyzedTarget, standardizedCoords);
                }
                if (losFilterCheckbox.checked) {
                    runLOSFilterAnalysis();
                }
            });
        }
        
        function getCurrentCoords() {
            return {
                lat: parseFloat(latInput.value),
                lon: parseFloat(lonInput.value)
            };
        }

        async function analyzePath(repeater, userCoords) {
            lastAnalyzedTarget = repeater;
            displaySelectedRepeaterInfo(repeater);
            losResultContainer.innerHTML = '<div class="flex justify-center items-center"><div class="loading-spinner"></div><p class="ml-4">Analyzing terrain...</p></div>';
            if (profileChart) profileChart.destroy();

            if (repeaterMarker) map.removeLayer(repeaterMarker);
            repeaterMarker = L.marker([repeater.lat, repeater.lon], {
                 icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                })
            }).addTo(map);
            repeaterMarker.options.customId = repeater.id;
            repeaterMarker.bindPopup(`<b>${repeater.callsign}</b>`).openPopup();

            const initialPoints = getPointsOnPath(userCoords, { lat: repeater.lat, lon: repeater.lon }, 100);
            
            try {
                let elevationProfile = await getElevationProfile(initialPoints);
                const userAntennaHeight = parseFloat(userHeightInput.value) || 10;
                let repeaterAntennaHeight = parseFloat(repeater.antennaHeight) || parseFloat(repeaterHeightInput.value) || 30;
                
                let { isVisible, obstructionPoint } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight);

                // --- Adaptive Sampling Logic ---
                if (isVisible) {
                    const closeApproachSegments = findCloseApproachSegments(elevationProfile, userAntennaHeight, repeaterAntennaHeight, 20);
                    if (closeApproachSegments.length > 0) {
                        losResultContainer.innerHTML = '<div class="flex justify-center items-center"><div class="loading-spinner"></div><p class="ml-4">Refining path analysis...</p></div>';
                        elevationProfile = await refineElevationProfile(elevationProfile, initialPoints, closeApproachSegments);
                        // Recalculate with the refined profile
                        ({ isVisible, obstructionPoint } = calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight));
                    }
                }

                displayLosResult(isVisible, obstructionPoint, userCoords, repeater);
                drawProfileChart(elevationProfile, userAntennaHeight, repeaterAntennaHeight, isVisible, obstructionPoint);
                drawPathOnMap(initialPoints, isVisible); // Draw original path line regardless of refinement

            } catch (error) {
                console.error("Error during analysis:", error);
                losResultContainer.innerHTML = `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                    <strong class="font-bold">Error!</strong>
                    <span class="block sm:inline">Could not fetch elevation data. ${error.message}</span>
                </div>`;
            }
        }

        function getPointsOnPath(start, end, numPoints = 100) {
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const t = i / (numPoints - 1);
                points.push({
                    lat: start.lat + t * (end.lat - start.lat),
                    lon: start.lon + t * (end.lon - start.lon)
                });
            }
            return points;
        }

        async function getElevationProfile(points) {
            if (points.length === 0) return [];
            const start = points[0];
            const end = points[points.length - 1];
            
            const isCanadianPath = (start.lat > 41 && end.lat > 41 && start.lon < -60 && end.lon < -60);

            let apiUrl;
            let isNrCan = false;
            if (isCanadianPath) {
                const path = `LINESTRING(${start.lon} ${start.lat}, ${end.lon} ${end.lat})`;
                apiUrl = `https://geogratis.gc.ca/services/elevation/cdem/profile?path=${encodeURIComponent(path)}&steps=${points.length - 2}`;
                isNrCan = true;
            } else {
                const latitudes = points.map(p => p.lat.toFixed(5)).join(',');
                const longitudes = points.map(p => p.lon.toFixed(5)).join(',');
                apiUrl = `https://api.open-meteo.com/v1/elevation?latitude=${latitudes}&longitude=${longitudes}`;
            }
            
            let response;
            const maxRetries = 3;
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                response = await fetch(apiUrl);
                if (response.ok) break;
                if (response.status === 429 && attempt < maxRetries) {
                    const retryAfter = attempt * 1000;
                    console.warn(`Rate limited. Retrying in ${retryAfter}ms...`);
                    await delay(retryAfter);
                } else {
                    throw new Error(`Elevation API request failed. Status: ${response.status}`);
                }
            }
            
            const data = await response.json();

            if (isNrCan) {
                if (!data || !Array.isArray(data)) throw new Error('Invalid data received from NRCan API.');
                return data.map(p => ({
                    elevation: p.altitude,
                    location: { lat: p.geometry.coordinates[1], lng: p.geometry.coordinates[0] }
                }));
            } else {
                if (!data.elevation) throw new Error('Invalid data received from Open-Meteo API.');
                return data.elevation.map((elevation, index) => ({
                    elevation: elevation,
                    location: { lat: points[index].lat, lng: points[index].lon }
                }));
            }
        }

        function calculateLineOfSight(elevationProfile, userAntennaHeight, repeaterAntennaHeight) {
            if (!elevationProfile || elevationProfile.length < 2) {
                return { isVisible: false, obstructionPoint: null };
            }

            const startPoint = elevationProfile[0];
            const endPoint = elevationProfile[elevationProfile.length - 1];
            const startElevation = startPoint.elevation + userAntennaHeight;
            const endElevation = endPoint.elevation + repeaterAntennaHeight;

            for (let i = 1; i < elevationProfile.length - 1; i++) {
                const intermediatePoint = elevationProfile[i];
                const fraction = i / (elevationProfile.length - 1);
                const losHeight = startElevation + fraction * (endElevation - startElevation);
                if (intermediatePoint.elevation > losHeight) {
                    return {
                        isVisible: false,
                        obstructionPoint: { ...intermediatePoint, losHeight: losHeight, distanceFraction: fraction }
                    };
                }
            }
            return { isVisible: true, obstructionPoint: null };
        }
        
        function findCloseApproachSegments(elevationProfile, userAntennaHeight, repeaterAntennaHeight, threshold) {
            const segments = [];
            if (elevationProfile.length < 2) return segments;

            const startElevation = elevationProfile[0].elevation + userAntennaHeight;
            const endElevation = elevationProfile[elevationProfile.length - 1].elevation + repeaterAntennaHeight;
            
            let currentSegment = null;

            for (let i = 1; i < elevationProfile.length - 1; i++) {
                const point = elevationProfile[i];
                const fraction = i / (elevationProfile.length - 1);
                const losHeight = startElevation + fraction * (endElevation - startElevation);
                const clearance = losHeight - point.elevation;

                if (clearance > 0 && clearance < threshold) {
                    if (!currentSegment) {
                        // Start a new segment, including one point before for context
                        currentSegment = { start: Math.max(0, i - 1) };
                    }
                } else {
                    if (currentSegment) {
                        // End the current segment, including one point after for context
                        currentSegment.end = Math.min(elevationProfile.length - 1, i);
                        segments.push(currentSegment);
                        currentSegment = null;
                    }
                }
            }
            // Close any open segment at the end of the path
            if (currentSegment) {
                currentSegment.end = elevationProfile.length - 1;
                segments.push(currentSegment);
            }
            return segments;
        }

        async function refineElevationProfile(initialProfile, initialPoints, segments) {
            let refinedProfile = [...initialProfile];
            let offset = 0; // Keep track of how much the array length changes

            for (const segment of segments) {
                const startPoint = initialPoints[segment.start];
                const endPoint = initialPoints[segment.end];
                
                // Get 50 new, high-resolution points within this segment
                const refinedPoints = getPointsOnPath(startPoint, endPoint, 50);
                const refinedSegmentProfile = await getElevationProfile(refinedPoints);

                // Replace the old, coarse segment with the new, refined one
                const pointsToRemove = segment.end - segment.start + 1;
                refinedProfile.splice(segment.start + offset, pointsToRemove, ...refinedSegmentProfile);
                
                // Update the offset for subsequent splices
                offset += refinedSegmentProfile.length - pointsToRemove;
            }
            return refinedProfile;
        }

        function displaySelectedRepeaterInfo(repeater) {
            selectedRepeaterInfoDiv.innerHTML = `
                <div class="text-left">
                    <p class="font-bold text-lg">${repeater.callsign}</p>
                    <p class="text-sm text-gray-600">${repeater.location}</p>
                    <div class="mt-2 text-sm text-gray-800 grid grid-cols-2 gap-x-4 gap-y-1">
                        <span><span class="font-semibold">Output:</span> ${repeater.outputFreq || 'N/A'} (${repeater.offset || 'N/A'})</span>
                        <span><span class="font-semibold">Input:</span> ${repeater.inputFreq || 'N/A'}</span>
                        ${repeater.uplinkTone !== 'N/A' ? `<span><span class="font-semibold">Tone:</span> ${repeater.uplinkTone}</span>` : ''}
                        <span><span class="font-semibold">Antenna Ht:</span> ${repeater.antennaHeight} m</span>
                    </div>
                </div>
            `;
        }

        function displayLosResult(isVisible, obstructionPoint, userCoords, repeater) {
            const distance = getDistance(userCoords, repeater).toFixed(2);
            let resultHTML;
            if (isVisible) {
                resultHTML = `<div class="bg-green-100 border-l-4 border-green-500 text-green-700 p-4">
                        <p class="font-bold text-xl">Line-of-Sight is CLEAR!</p>
                        <p>The path to ${repeater.callsign} (${distance} km) appears to be unobstructed by terrain.</p>
                    </div>`;
            } else {
                const obstructionDist = (distance * obstructionPoint.distanceFraction).toFixed(2);
                resultHTML = `<div class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4">
                        <p class="font-bold text-xl">Line-of-Sight is OBSTRUCTED</p>
                        <p>The path to ${repeater.callsign} (${distance} km) is blocked by terrain.</p>
                        <p>The highest obstruction is approximately ${obstructionDist} km from your location.</p>
                    </div>`;
            }
            losResultContainer.innerHTML = resultHTML;
        }

        function drawProfileChart(elevationData, userAntennaHeight, repeaterAntennaHeight, isVisible, obstructionPoint) {
            if (profileChart) {
                profileChart.destroy();
            }
            const labels = elevationData.map((_, i) => i);
            const terrainData = elevationData.map(p => p.elevation);
            const startElevation = elevationData[0].elevation + userAntennaHeight;
            const endElevation = elevationData[elevationData.length - 1].elevation + repeaterAntennaHeight;
            const losData = elevationData.map((_, i) => {
                const fraction = i / (elevationData.length - 1);
                return startElevation + fraction * (endElevation - startElevation);
            });

            const datasets = [{
                label: 'Terrain Profile', data: terrainData, borderColor: 'rgb(139, 69, 19)', backgroundColor: 'rgba(139, 69, 19, 0.2)',
                fill: true, pointRadius: 0, borderWidth: 2
            }, {
                label: 'Line of Sight', data: losData, borderColor: isVisible ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)',
                fill: false, pointRadius: 0, borderWidth: 3, borderDash: [5, 5]
            }];
            
            if (obstructionPoint) {
                const obstructionIndex = Math.round(obstructionPoint.distanceFraction * (elevationData.length - 1));
                datasets.push({
                    label: 'Obstruction', data: [{x: obstructionIndex, y: obstructionPoint.elevation}],
                    backgroundColor: 'rgb(239, 68, 68)', pointRadius: 6, pointStyle: 'crossRot', type: 'scatter'
                });
            }

            const ctx = profileChartCanvas.getContext('2d');
            profileChart = new Chart(ctx, {
                type: 'line',
                data: { labels: labels, datasets: datasets },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Elevation Profile' },
                        legend: { position: 'top' },
                        tooltip: { callbacks: {
                            title: (context) => `Point ${context[0].label} on Path`,
                            label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(1)} m`
                        }}
                    },
                    scales: {
                        x: { title: { display: true, text: 'Path from You to Repeater' }, ticks: { display: false } },
                        y: { title: { display: true, text: 'Elevation (meters)' } }
                    }
                }
            });
        }

        function drawPathOnMap(points, isVisible) {
            if (pathLine) map.removeLayer(pathLine);
            const latLngs = points.map(p => [p.lat, p.lon]);
            pathLine = L.polyline(latLngs, { color: isVisible ? 'green' : 'red', weight: 4, opacity: 0.8 }).addTo(map);
            map.fitBounds(pathLine.getBounds().pad(0.1));
        }

        function getDistance(coords1, coords2) {
            const R = 6371; // km
            const dLat = (coords1.lat - coords2.lat) * Math.PI / 180;
            const dLon = (coords1.lon - coords2.lon) * Math.PI / 180;
            const a = 0.5 - Math.cos(dLat) / 2 + Math.cos(coords2.lat * Math.PI / 180) * Math.cos(coords1.lat * Math.PI / 180) * (1 - Math.cos(dLon)) / 2;
            return R * 2 * Math.asin(Math.sqrt(a));
        }
        
        window.analyzePathFromPopup = analyzePathFromPopup;

        function togglePlaceMarkerMode(mode, id = null) {
            isPlacingMarker = !isPlacingMarker;
            placementInfo.mode = isPlacingMarker ? mode : null;
            placementInfo.id = id;
            
            const mapContainer = document.getElementById('map');
            if (isPlacingMarker) {
                mapContainer.classList.add('crosshair-cursor');
                addMarkerBtn.textContent = 'Cancel Placement';
                addMarkerBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                addMarkerBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                if (placementInfo.mode === 'custom') {
                    customMarkerInputContainer.classList.remove('hidden');
                }
            } else {
                mapContainer.classList.remove('crosshair-cursor');
                addMarkerBtn.textContent = 'Place Custom Marker';
                addMarkerBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                addMarkerBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                customMarkerInputContainer.classList.add('hidden');
            }
        }

        function onMapClick(e) {
            if (!isPlacingMarker) return;
            
            if (placementInfo.mode === 'custom') {
                const name = customMarkerNameInput.value.trim() || `Custom Marker ${customMarkers.length + 1}`;
                const newMarkerData = {
                    id: `custom-${Date.now()}`,
                    callsign: name,
                    lat: e.latlng.lat,
                    lon: e.latlng.lng,
                    location: `Custom Marker (${e.latlng.lat.toFixed(3)}, ${e.latlng.lng.toFixed(3)})`,
                    antennaHeight: parseFloat(repeaterHeightInput.value) || 30
                };
                customMarkers.push(newMarkerData);
                displayCustomMarkers();
                customMarkerNameInput.value = '';
            } else if (placementInfo.mode === 'repeater') {
                const repeater = repeaterData.find(r => r.id === placementInfo.id);
                if (repeater) {
                    repeater.lat = e.latlng.lat;
                    repeater.lon = e.latlng.lng;
                    delete repeater.locationUnknown;
                    displayRepeaters(repeaterData, getCurrentCoords());
                }
            }
            
            togglePlaceMarkerMode(null); // Exit placement mode
        }

        function displayCustomMarkers() {
            customListDiv.innerHTML = '';
            customMarkerLayer.clearLayers();

            if (customMarkers.length === 0) {
                customListDiv.innerHTML = '<p class="p-3 text-gray-500">Click "Place Custom Marker" to add locations.</p>';
            }

            customMarkers.forEach(markerData => {
                const userCoords = getCurrentCoords();
                const distance = getDistance(userCoords, markerData).toFixed(1);

                const item = document.createElement('div');
                item.className = 'p-3 border rounded-lg hover:bg-gray-100';
                item.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="flex-grow cursor-pointer" data-id="${markerData.id}">
                            <p class="font-bold">${markerData.callsign}</p>
                            <p class="text-sm text-gray-600">${markerData.location} (${distance} km)</p>
                        </div>
                        <button class="delete-custom-marker text-red-500 hover:text-red-700 font-bold ml-2 p-1">&times;</button>
                    </div>
                     <div class="mt-1">
                        <label for="height-${markerData.id}" class="text-xs font-medium">Antenna Ht (m):</label>
                        <input type="number" id="height-${markerData.id}" value="${markerData.antennaHeight}" class="w-20 ml-1 px-1 py-0.5 text-xs border border-gray-300 rounded">
                    </div>
                `;
                item.querySelector('.flex-grow').onclick = () => analyzePath(markerData, userCoords);
                item.querySelector('.delete-custom-marker').onclick = (e) => {
                    e.stopPropagation(); // Prevent the click from triggering the analysis
                    deleteCustomMarker(markerData.id);
                };

                const heightInput = item.querySelector(`#height-${markerData.id}`);
                heightInput.addEventListener('input', (e) => {
                    const newHeight = parseFloat(e.target.value);
                    const targetMarker = customMarkers.find(m => m.id === markerData.id);
                    if (targetMarker && !isNaN(newHeight)) {
                        targetMarker.antennaHeight = newHeight;
                        if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerData.id) {
                            analyzePath(targetMarker, getCurrentCoords());
                        }
                    }
                });

                customListDiv.appendChild(item);

                const marker = L.marker([markerData.lat, markerData.lon], {
                    draggable: true,
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
                    })
                }).addTo(customMarkerLayer);
                
                marker.on('dragend', (event) => {
                    const newCoords = event.target.getLatLng();
                    markerData.lat = newCoords.lat;
                    markerData.lon = newCoords.lng;
                    markerData.location = `Custom Marker (${newCoords.lat.toFixed(3)}, ${newCoords.lng.toFixed(3)})`;
                    displayCustomMarkers();
                    if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerData.id) {
                        analyzePath(markerData, getCurrentCoords());
                    }
                });
            });
        }
        
        function deleteCustomMarker(markerId) {
            const index = customMarkers.findIndex(m => m.id === markerId);
            if (index > -1) {
                if (lastAnalyzedTarget && lastAnalyzedTarget.id === markerId) {
                    lastAnalyzedTarget = null;
                    if (repeaterMarker) map.removeLayer(repeaterMarker);
                    repeaterMarker = null;
                    if (pathLine) map.removeLayer(pathLine);
                    if (profileChart) profileChart.destroy();
                    losResultContainer.innerHTML = '<p class="p-3 text-gray-500">Select a repeater from the list to analyze the path.</p>';
                    selectedRepeaterInfoDiv.innerHTML = '<p class="text-gray-500">Select a repeater to see its details here.</p>';
                }
                customMarkers.splice(index, 1);
                displayCustomMarkers();
            }
        }
        
        function clearLocalStorage() {
            if(confirm("Are you sure you want to delete all saved data? This cannot be undone.")) {
                localStorage.clear();
                window.location.reload();
            }
        }

        function getSetNameInput() {
            const desktopInput = document.getElementById('set-name-input-desktop');
            const mobileInput = document.getElementById('set-name-input-mobile');
            return window.innerWidth < 1024 ? mobileInput : desktopInput;
        }

        function getSetSelect() {
            const desktopSelect = document.getElementById('set-select-desktop');
            const mobileSelect = document.getElementById('set-select-mobile');
            return window.innerWidth < 1024 ? mobileSelect : desktopSelect;
        }

        function showSetErrorMessage(show) {
             document.getElementById('set-error-msg-desktop').classList.toggle('hidden', !show);
             document.getElementById('set-error-msg-mobile').classList.toggle('hidden', !show);
        }

        function saveCurrentSet() {
            const setNameInput = getSetNameInput();
            const setName = setNameInput.value.trim();
            if (!setName) {
                showSetErrorMessage(true);
                return;
            }
            showSetErrorMessage(false);

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            savedSets[setName] = {
                repeaterData: repeaterData,
                customMarkers: customMarkers
            };

            localStorage.setItem('repeaterSets', JSON.stringify(savedSets));
            localStorage.setItem('lastRepeaterSet', setName);
            updateSetSelector(Object.keys(savedSets), setName);
            setNameInput.value = '';
            filterStatusDiv.textContent = `Set "${setName}" saved.`;
            setTimeout(() => filterStatusDiv.textContent = '', 3000);
        }

        function deleteCurrentSet() {
            const setSelect = getSetSelect();
            const setName = setSelect.value;
            if (!setName) {
                filterStatusDiv.textContent = "No set selected to delete.";
                setTimeout(() => filterStatusDiv.textContent = '', 3000);
                return;
            }

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            delete savedSets[setName];
            localStorage.setItem('repeaterSets', JSON.stringify(savedSets));
            
            if (localStorage.getItem('lastRepeaterSet') === setName) {
                localStorage.removeItem('lastRepeaterSet');
            }
            
            window.location.reload();
        }

        function loadSelectedSet(event) {
            const setName = event.target.value;
            if (!setName) return;

            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            if (savedSets[setName]) {
                localStorage.setItem('lastRepeaterSet', setName);
                window.location.reload();
            }
        }

        function loadFromLocalStorage() {
            const savedSets = JSON.parse(localStorage.getItem('repeaterSets')) || {};
            const lastSetName = localStorage.getItem('lastRepeaterSet');
            
            updateSetSelector(Object.keys(savedSets), lastSetName);

            if (lastSetName && savedSets[lastSetName]) {
                repeaterData = savedSets[lastSetName].repeaterData || [];
                customMarkers = savedSets[lastSetName].customMarkers || [];

                filterStatusDiv.textContent = `Loaded set: ${lastSetName}`;
                displayRepeaters(repeaterData, getCurrentCoords());
                displayCustomMarkers();
            }
        }

        function updateSetSelector(setNames, currentSet) {
            ['desktop', 'mobile'].forEach(view => {
                const setSelect = document.getElementById(`set-select-${view}`);
                setSelect.innerHTML = '<option value="">Select a set...</option>';
                setNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    if (name === currentSet) {
                        option.selected = true;
                    }
                    setSelect.appendChild(option);
                });
            });
        }

        function handleDefaultRepeaterHeightChange(e) {
            const newDefaultHeight = parseFloat(e.target.value);
            if (isNaN(newDefaultHeight)) return;

            // Update any repeater that was using the old default value
            repeaterData.forEach(repeater => {
                if (repeater.antennaHeight === previousDefaultRepeaterHeight) {
                    repeater.antennaHeight = newDefaultHeight;
                }
            });
            
            // Update custom markers too
             customMarkers.forEach(marker => {
                if (marker.antennaHeight === previousDefaultRepeaterHeight) {
                    marker.antennaHeight = newDefaultHeight;
                }
            });

            // Redraw the lists to show the new default values
            displayRepeaters(repeaterData, getCurrentCoords());
            displayCustomMarkers();

            // Re-analyze if a target is selected
            if (lastAnalyzedTarget) {
                // Find the latest version of the target data
                const currentTargetData = repeaterData.find(r => r.id === lastAnalyzedTarget.id) || customMarkers.find(m => m.id === lastAnalyzedTarget.id);
                if(currentTargetData) {
                   analyzePath(currentTargetData, getCurrentCoords());
                }
            }
            
            // Update the previous value for the next change
            previousDefaultRepeaterHeight = newDefaultHeight;
        }

    </script>
</body>
</html>
